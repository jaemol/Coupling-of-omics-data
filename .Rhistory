meanData  <- unname(apply(inData, 2, mean))
stdData   <- unname(apply(inData, 2, sd))
varData   <- unname(apply(inData, 2, var))
ratioData <- unname(apply(inData, 2, function(x){length(which(x==0))/length(x)}))
plot(meanData, main = "Mean Data")
plot(stdData, main = "Standard Variations")
plot(varData, main = "Variance")
plot(ratioData, main = "Singleton ratios")
## filtering upon the relative standard deviation
meanData  <- unname(apply(inData, 2, mean))
stdData   <- unname(apply(inData, 2, sd))
varData   <- unname(apply(inData, 2, var))
ratioData <- unname(apply(inData, 2, function(x){length(which(x==0))/length(x)}))
plot(stdData, main = "Standard Variations")
relativeStdData <- unname(apply(inData, 2, mean/sd))
relativeSTD <- unname(apply(inData, 2, function(x){sd(x)/mean(x)}))
relativeSTD
plot(relativeSTD)
rm(list=ls())
# Finding just the results from week two
data_week02_16s   <- data_16s[data_16s$SAMPLEWEEK == 'Week 02',]
### Script to extract data from testdatasheet from Katrine ###
### Only want the data from e.g. week 2 and the appropriate columns ###
# loading libraries
#library(dplyr)
library(gsubfn)
# beginning function #
extracting_data_KAT <- function() {
# loading in the two datasheets
data_16s  <- read.table("C:/Users/Jmoll/Documents/GitHub/Coupling-of-omics-data/Testdata/allData_16S_cleaned.txt")
data_qpcr <- read.table("C:/Users/Jmoll/Documents/GitHub/Coupling-of-omics-data/Testdata/allData_qPCR_cleaned.txt")
# Finding just the results from week two
data_week02_16s   <- data_16s[data_16s$SAMPLEWEEK == 'Week 02',]
data_week02_qpcr  <- data_qpcr[data_qpcr$SAMPLEWEEK == 'Week 02',]
# next, include only testID (PIG_DATE), OUA and the results of the analyses
pure_data_16s   <- subset(data_week02_16s, select = -c(PIG, DATE, WEANING_TIME, GROUP, Newlytreated,
WEEK, SAMPLEWEEK, Florkem, Metacam, Zactran,
Antibiotic, Treatment_group, Treatment_date, CorrectedGroup,
PIG.1, DATE.1, OUA.1, PIG_DATE.1, OriginalNAME))
pure_data_qpcr  <- subset(data_week02_qpcr, select = -c(PIG, DATE, WEANING_TIME, GROUP, Newlytreated,
WEEK, SAMPLEWEEK, Florkem, Metacam, Zactran,
Antibiotic, Treatment_group, Treatment_date, CorrectedGroup, sample))
# extract two arrays of testIDs, and find which are common between them both
testID_16s  <- pure_data_16s$PIG_DATE
testID_qpcr <- pure_data_qpcr$PIG_DATE
common_IDs  <- intersect(testID_16s, testID_qpcr)
# only keep relevant testIDs
pure_data_16s   = pure_data_16s[pure_data_16s$PIG_DATE %in% common_IDs, ]
pure_data_qpcr  = pure_data_qpcr[pure_data_qpcr$PIG_DATE %in% common_IDs, ]
# sort the datasets based testID, append whilst removing 1 edition of testID and OUA
pure_data_16s   = pure_data_16s[order(pure_data_16s$PIG_DATE), ]
pure_data_qpcr  = pure_data_qpcr[order(pure_data_qpcr$PIG_DATE), ]
pure_data_qpcr  = subset(pure_data_qpcr, select = -c(PIG_DATE, OUA))
# now, append the datasets, to get one set
complete_data <- cbind(pure_data_16s, pure_data_qpcr, deparse.level = 1)
# keeping the length of 16s and qpcr data - JUST the results, no ID or OUA
len_16s   <- length(pure_data_16s[1,]) - 2
len_qpcr  <- length(pure_data_qpcr[1,])
# dropping the variables, except the resulting data set and the respective length of the datasets
rm(list=setdiff(ls(), c("complete_data", "len_16s", "len_qpcr")))
list(complete_data, len_16s, len_qpcr)
}
source("C:/Users/Jmoll/Documents/GitHub/Coupling-of-omics-data/Programming/extracting_data_KAT.R")
# loading in the data
list[data, len_16s, len_qpcr] <- extracting_data_KAT()
# Great, now trying to cluster
options(warn = 0) # set=2 to end loops when warnings occur
# Gonna write it out first, then make it into a function
inData = data
testID  <- inData$PIG_DATE
OUA     <- inData$OUA
inData = subset(inData, select = -c(PIG_DATE, OUA))
# if the variance is equal to zero, then its a zero-column
#which(unname(apply(inData, 2, var))==0)
throwAway <- which(apply(inData, 2, var)==0)[]
# dropping columns by index
inData = inData[, -throwAway]
throwAway
## finding different interesting information on the set
## mean, var, STD, ratio of zeros
meanData  <- apply(inData, 2, mean)[]
meanData
meanData[2]
meanData[[4]]
## finding different interesting information on the set
## mean, var, STD, ratio of zeros
meanData  <- unname(apply(inData, 2, mean))
stdData   <- unname(apply(inData, 2, sd))
varData   <- unname(apply(inData, 2, var))
ratioData <- unname(apply(inData, 2, function(x){length(which(x==0))/length(x)}))
plot(meanData, main = "Mean Data")
plot(stdData, main = "Standard Variations")
plot(varData, main = "Variance")
plot(ratioData, main = "Singleton ratios")
plot(sort(meanData, main = "Mean Data"))
plot(sort(meanData), main = "Mean Data")
plot(sort(meanData), main = "Mean Data")
plot(sort(stdData), main = "Standard Variations")
plot(sort(varData), main = "Variance")
plot(sort(ratioData), main = "Singleton ratios")
min(varData)
par(mfrow=c(2,1), mar=c(2,2,0,0))
plot(sort(ratioData))
plot(diff(sort(ratioData))~sort(ratioData)[-1])
abline(h=0.85)
diff(x^a,x)
plot(sort(ratioData), main = "Singleton ratios")
par(mfrow=c(1,1))
plot(sort(ratioData), main = "Singleton ratios")
par(mfrow=c(1,1), mar=c(1,1,0,0))
plot(sort(ratioData), main = "Singleton ratios")
par(mfrow=c(1,1), mar=c(0,0,0,0))
plot(sort(ratioData), main = "Singleton ratios")
par(mfrow=c(1,1), mar=c(2,2,2,2))
plot(sort(ratioData), main = "Singleton ratios")
?mar
??mar
## finding different interesting information on the set
## mean, var, STD, ratio of zeros
meanData  <- unname(apply(inData, 2, mean))
stdData   <- unname(apply(inData, 2, sd))
varData   <- unname(apply(inData, 2, var))
ratioData <- unname(apply(inData, 2, function(x){length(which(x==0))/length(x)}))
plot(sort(meanData), main = "Mean Data")
plot(sort(stdData), main = "Standard Variations")
plot(sort(varData), main = "Variance")
plot(sort(ratioData), main = "Singleton ratios")
rm(throwAway)
install.packages("dbscan")
?dbscan
??dbscan
# Gonna write it out first, then make it into a function
inData = data
testID  <- inData$PIG_DATE
OUA     <- inData$OUA
inData = subset(inData, select = -c(PIG_DATE, OUA))
# if the variance is equal to zero, then its a zero-column
#which(unname(apply(inData, 2, var))==0)
throwAway <- which(apply(inData, 2, var)==0)[]
# dropping columns by index
inData = inData[, -throwAway]
rm(throwAway) # to save memory
## finding different interesting information on the set
## mean, var, STD, ratio of zeros
meanData  <- unname(apply(inData, 2, mean))
stdData   <- unname(apply(inData, 2, sd))
varData   <- unname(apply(inData, 2, var))
ratioData <- unname(apply(inData, 2, function(x){length(which(x==0))/length(x)}))
CV        <- unname(apply(inData, 2, function(x){sd(x)/mean(x)}))
plot(sort(meanData), main = "Mean Data")
plot(sort(stdData), main = "Standard Variations")
plot(sort(varData), main = "Variance")
plot(sort(ratioData), main = "Singleton ratios")
plot(sort(CV, main = "Relative standard deviation"))
plot(sort(CV), main = "Relative standard deviation")
install.packages("drm")
model.drm <- drm(data = ratioData, fct = MM.1)
# Loading libraries
library(drc)
library(ggplot2)
# Loading libraries
library(drm)
# Loading libraries
library("drc")
# Loading libraries
library("drm")
# Loading libraries
library(drm)
install.packages("drc")
# Loading libraries
library(drc)
library(ggplot2)
# fitting Michaelis-Menten function to data
Vmax  <- max(ratioData)
K     <- Vmax / 2
model.drm <- drm(data = ratioData, fct = MM.1)
model.drm <- drm(data = ratioData)
?fct
??fct
?drm
model.drm <- drm(data = ratioData, fct = MM.2())
model.drm <- drm(data = ratioData, fct = MM.1())
?attach
k     <- Vmax / 2
mmModel <- nls(start = list(Vm=Vmax, K=k))
?nls
mmModel <- nls(data = ratioData, start = list(Vm=Vmax, K=k))
ratioData[2]
plot(ratioData)
plot(sort(ratioData))
# Loading libraries
library(drc)
library(ggplot2)
options(warn = 0) # set=2 to end loops when warnings occur
# Gonna write it out first, then make it into a function
inData = data
testID  <- inData$PIG_DATE
OUA     <- inData$OUA
inData = subset(inData, select = -c(PIG_DATE, OUA))
# if the variance is equal to zero, then its a zero-column
#which(unname(apply(inData, 2, var))==0)
throwAway <- which(apply(inData, 2, var)==0)[]
# dropping columns by index
inData = inData[, -throwAway]
rm(throwAway) # to save memory
## finding different interesting information on the set
## mean, var, STD, ratio of zeros
meanData  <- unname(apply(inData, 2, mean))
stdData   <- unname(apply(inData, 2, sd))
varData   <- unname(apply(inData, 2, var))
ratioData <- unname(apply(inData, 2, function(x){length(which(x==0))/length(x)}))
CV        <- unname(apply(inData, 2, function(x){sd(x)/mean(x)}))
plot(sort(meanData), main = "Mean Data")
plot(sort(stdData), main = "Standard Variations")
plot(sort(varData), main = "Variance")
plot(sort(ratioData), main = "Singleton ratios")
plot(sort(CV), main = "Relative standard deviation")
# fitting Michaelis-Menten function to data
Vmax  <- max(ratioData)
k     <- Vmax / 2
mmModel <- nls(rate ~ Vm * conc / (K + conc),data = sort(ratioData), start = list(Vm=Vmax, K=k))
ratData = list(ratioData)
ratData = list(sort(ratioData))
mmModel <- nls(rate ~ Vm * conc / (K + conc), data = sort(ratData), start = list(Vm=Vmax, K=k))
ratData = list(ratioData)
# fitting Michaelis-Menten function to data
Vmax  <- max(ratioData)
k     <- Vmax / 2
mmModel <- nls(rate ~ Vm * conc / (K + conc), data = sort(ratData), start = list(Vm=Vmax, K=k))
ratData
ratData[2]
ratData[[2]]
ratData[1000]
ratioData[2]
list(ratioData[2])
ratData
ratData[[1]]
ratData[[1]][2]
ratData = list(ratioData[[1]])
# fitting Michaelis-Menten function to data
Vmax  <- max(ratioData)
k     <- Vmax / 2
mmModel <- nls(rate ~ Vm * conc / (K + conc), data = sort(ratData), start = list(Vm=Vmax, K=k))
ratData = ratioData
# fitting Michaelis-Menten function to data
Vmax  <- max(ratioData)
k     <- Vmax / 2
mmModel <- nls(rate ~ Vm * conc / (K + conc), data = sort(ratData), start = list(Vm=Vmax, K=k))
class(ratData)
ratData = list(ratioData)
class(ratData)
mmModel <- nls(rate ~ Vm * conc / (K + conc), data = sort(ratData), start = list(Vm=Vmax, K=k))
ratData
ratData[[1]]
?attach
plot(sort(ratioData))
plot(diff(sort(ratioData))~sort(ratioData)[-1])
abline(h=0.85)
abline(h=0.85)
par(mfrow=c(2,1))
plot(sort(ratioData))
plot(diff(sort(ratioData))~sort(ratioData)[-1])
par(mfrow=c(2,1))
plot(sort(ratioData))
plot(diff(sort(ratioData)),sort(ratioData)[-1])
abline(h=0.85)
par(mfrow=c(2,1))
plot(sort(ratioData))
abline(h=0.85)
plot(diff(sort(ratioData)),sort(ratioData)[-1])
abline(h=0.85)
par(mfrow=c(1,2))
plot(sort(ratioData))
abline(h=0.85)
plot(diff(sort(ratioData)),sort(ratioData)[-1])
abline(h=0.85)
plot(diff(sort(ratioData)),sort(ratioData)[-1], '-o')
plot(diff(sort(ratioData)),sort(ratioData)[-1], "-o")
plot(diff(sort(ratioData)),sort(ratioData)[-1], type= "-o")
?plot
plot(diff(sort(ratioData)),sort(ratioData)[-1], type= "l")
plot(sort(ratioData), type="lo")
par(mfrow=c(1,2))
plot(sort(ratioData), type="b")
abline(h=0.85)
plot(diff(sort(ratioData)),sort(ratioData)[-1], type= "b")
abline(h=0.85)
ratData = list(ratioData)
# fitting Michaelis-Menten function to data
Vmax  <- max(ratioData)
k     <- Vmax / 2
mmModel <- nls(rate ~ Vm * conc / (K + conc), data = sort(ratData), start = list(Vm=Vmax, K=k))
mmModel <- nls(rate ~ Vm * conc / (K + conc), data = head(sort(ratData[[1]], decreasing=FALSE),3), start = list(Vm=Vmax, K=k))
ratData
ratData[5]
ratData[[5]]
mmModel <- nls(rate ~ Vm * conc / (K + conc), data = ratData, start = list(Vm=Vmax, K=k))
par(mfrow=c(1,2))
plot(sort(ratioData), type="b")
abline(h=0.85)
plot(diff(sort(ratioData)),sort(ratioData)[-1], type= "b")
abline(h=0.85)
par(mfrow=c(1,2))
plot(sort(ratioData), type="b")
abline(h=0.85)
plot(diff(sort(ratioData)),sort(ratioData)[-1], type= "b")
abline(h=0.85)
par(mfrow=c(1,2))
plot(sort(ratioData), type="b")
abline(h=0.65)
plot(diff(sort(ratioData)),sort(ratioData)[-1], type= "b")
abline(h=0.65)
par(mfrow=c(1,2))
plot(sort(ratioData), type="b")
abline(h=0.65)
abline(h=0.70)
plot(diff(sort(ratioData)),sort(ratioData)[-1], type= "b")
abline(h=0.65)
abline(h=0.70)
?seq
time_frame <- seq(from = 1, to = length(ratioData)), by = 1)
time_frame <- seq(from = 1, to = length(ratioData), by = 1)
length(time_frame)
length(ratioData)
mmModel <- nls(ratioData ~ Vm*time_frame/(K+time_frame), start = list(Vm=Vmax, K=k))
coef(mmModel)
Vmax
k
?confint
confint(mmModel, level = 0.9)
coef(mmModel)
confint(mmModel, level = 0.9)
plot(mmModel)
lines(mmModel)
mmModel
predict(mmModel)
plot(ratioData ~ time_frame)
plot(sort(ratioData) ~ time_frame)
par(mfrow=c(1,1))
plot(sort(ratioData) ~ time_frame)
lines(predict(mmModel) ~ time_frame)
mmModel <- nls(sort(ratioData) ~ Vm*time_frame/(K+time_frame), start = list(Vm=Vmax, K=k))
coef(mmModel)
confint(mmModel, level = 0.9)
plot(sort(ratioData) ~ time_frame)
lines(predict(mmModel) ~ time_frame)
lines(predict(mmModel) ~ time_frame, col = "red")
lines(predict(mmModel) ~ time_frame, col = "red", pch = 5)
plot(sort(ratioData) ~ time_frame, col = "blue")
lines(predict(mmModel) ~ time_frame, col = "red")
plot(sort(ratioData) ~ time_frame, col = "grey")
lines(predict(mmModel) ~ time_frame, col = "red")
?plot
lines(predict(mmModel) ~ time_frame, lwd = 1, col = "dark red")
lines(predict(mmModel) ~ time_frame, lwd = 3, col = "dark red")
plot(sort(ratioData) ~ time_frame, col = "grey")
lines(predict(mmModel) ~ time_frame, lwd = 3, col = "dark red")
?nls
mmModel.formula
mmModel$m
mmModel$data
mmModel$call
mmModel$control
Summary(mmModel)
summary(mmModel)
diff(mmModel)
AIC(mmModel)
library(ggplot2)
# finding local maxima, potentiel knee points
which(diff(sign(diff(ratioData)))==-2)+1
# finding local maxima, potentiel knee points
length(which(diff(sign(diff(ratioData)))==-2)+1)
# finding the linear fit from origo to asymptote
a_linearFit <- max(ratioData) / length(ratioData)
min(ratioData)
min(time_frame)
# finding the linear fit from origo to asymptote
a_linearFit <- max(ratioData) / length(time_frame)
is(length(ratioData) == length(time_frame))
length(ratioData) == length(time_frame)
b_linearFit <- min(ratioData) - a_linearFit*min(time_frame)
# finding local maxima, potentiel knee points
kneePoints_collected <- which(diff(sign(diff(ratioData)))==-2)+1
# parameters estimated including confidence interval
coef(mmModel)
# parameters estimated including confidence interval
coef(mmModel)[1]
# parameters estimated including confidence interval
coef(mmModel)[[1]]
# updating to estimated parameters
Vmax = coef(mmModel)[[1]]
K    = coef(mmModel)[[2]]
K
# using distance formular on all knee points to line
# distance formula: d = abs(a*x+b-y)/sqrt(a^2+1)
longest_distance <- 0
for (i in kneePoints_collected) {
temp_x = i
temp_y = Vmax*temp_x / (K*temp_x)
dist = abs(a_linearFit*temp_x + b_linearFit-temp_y)/sqrt(a_linearFit^2+1)
if (dist >= longest_distance) {longest_distance = dist}
}
longest_distance
# using distance formular on all knee points to line
# distance formula: d = abs(a*x+b-y)/sqrt(a^2+1)
longest_distance  <- 0
longest_x         <- 0
for (i in kneePoints_collected) {
temp_x = i
temp_y = Vmax*temp_x / (K*temp_x)
dist = abs(a_linearFit*temp_x + b_linearFit-temp_y)/sqrt(a_linearFit^2+1)
if (dist >= longest_distance) {longest_distance = dist; longest_x = temp_x}
}
longest_x
length(ratioData)
for (i in kneePoints_collected) {
temp_x = i
temp_y = Vmax*temp_x / (K*temp_x)
dist = abs(a_linearFit*temp_x + b_linearFit-temp_y)/sqrt(a_linearFit^2+1)
print(dist)
if (dist >= longest_distance) {longest_distance = dist; longest_x = temp_x}
}
kneePoints_collected
temp <- 0
for (i in kneePoints_collected) {
temp_x = i
temp_y = Vmax*temp_x / (K*temp_x)
dist = abs(a_linearFit*temp_x + b_linearFit-temp_y)/sqrt(a_linearFit^2+1)
print(dist)
if (dist >= longest_distance) {longest_distance = dist; longest_x = temp_x}
temp = temp+1
print(temp)
}
for (i in kneePoints_collected) {
temp_x = i
temp_y = Vmax*temp_x / (K*temp_x)
dist = abs(a_linearFit*temp_x + b_linearFit-temp_y)/sqrt(a_linearFit^2+1)
print(dist)
if (dist >= longest_distance) {longest_distance = dist; longest_x = temp_x}
}
longest_x
ratioData[longest_x]
# visualizing the model in relation to ratio Data
plot(sort(ratioData) ~ time_frame, col = "grey")
lines(predict(mmModel) ~ time_frame, lwd = 3, col = "dark red")
abline(h = 0.51111)
cutOff <- ratioData[longest_x]
plot(ratioData)
# defining the cutoff threshold
threshold_ratio <- ratioData[longest_x]
which(ratioData > threshold_ratio)
length(which(ratioData > threshold_ratio))
length(ratioData)
length(which(ratioData > threshold_ratio))-length(ratioData)
plot(sort(ratioData))
?sign
which(ratioData <= threshold_ratio)
# if the ratioData is above the found cutoff, it is to be removed
throwAway <- which(ratioData <= threshold_ratio)
# dropping columns by index
inData = inData[, throwAway]
rm(throwAway) # to save memory
outData = inData
outData = inData
library(gsubfn)
rm(list=setdiff(ls(), c"outData", "testID", "OUA"))
rm(list=setdiff(ls(), c"outData", "testID", "OUA"))
rm(list=setdiff(ls(), c"outData", "testID", "OUA"))
rm(list=setdiff(ls(), c("outData", "testID", "OUA")))
source("C:/Users/Jmoll/Documents/GitHub/Coupling-of-omics-data/Programming/data_filtering.R")
list[data, testID, OUA]       <- data_filtering(data = data)
list[data, testID, OUA]       <- data_filtering(data)
source("C:/Users/Jmoll/Documents/GitHub/Coupling-of-omics-data/Programming/data_filtering.R")
# loading in the data
list[data, len_16s, len_qpcr] <- extracting_data_KAT()
list[data, testID, OUA]       <- data_filtering(data)
setwd("~/GitHub/Coupling-of-omics-data")
# loading libraries
library(vegan)
# loading functions
source("Programming/extracting_data_NATH.R")
source("Programming/data_filtering.R")
source("Programming/data_analyze.R")
# loading NetCoMi library
library(NetCoMi)
if(!requireNamespace("BiocManager", quietly = TRUE)){
utils::install.packages("BiocManager")
}
BiocManager::install(pkgs = c("Biobase", "doSNOW", "fdrtool", "filematrix",
"foreach", "graphics", "grDevices", "gtools",
"huge", "igraph", "MASS", "Matrix", "phyloseq",
"pulsar", "qgraph", "Rdpack", "snow", "SPRING",
"stats", "utils", "vegan", "WGCNA"))
BiocManager::install("GO.db")
devtools::install_github("GraceYoon/SPRING")
install.packages("devtools")
# install.packages("devtools")
devtools::install_github("GraceYoon/SPRING")
devtools::install_github("zdk123/SpiecEasi")
devtools::install_github("stefpeschel/NetCoMi",
dependencies = c("Depends", "Imports"),
repos = c("https://cloud.r-project.org/",
BiocManager::repositories()))
rm(list=ls())
# loading NetCoMi library
library(NetCoMi)
devtools::install_github("stefpeschel/NetCoMi",
dependencies = c("Depends", "Imports"),
repos = c("https://cloud.r-project.org/",
BiocManager::repositories()))
# loading NetCoMi library
library(NetCoMi)
