mmModel <- nls(sort(ratioData) ~ Vm*time_frame/(K+time_frame), start = list(Vm=Vmax, K=k))
coef(mmModel)
confint(mmModel, level = 0.9)
plot(sort(ratioData) ~ time_frame)
lines(predict(mmModel) ~ time_frame)
lines(predict(mmModel) ~ time_frame, col = "red")
lines(predict(mmModel) ~ time_frame, col = "red", pch = 5)
plot(sort(ratioData) ~ time_frame, col = "blue")
lines(predict(mmModel) ~ time_frame, col = "red")
plot(sort(ratioData) ~ time_frame, col = "grey")
lines(predict(mmModel) ~ time_frame, col = "red")
?plot
lines(predict(mmModel) ~ time_frame, lwd = 1, col = "dark red")
lines(predict(mmModel) ~ time_frame, lwd = 3, col = "dark red")
plot(sort(ratioData) ~ time_frame, col = "grey")
lines(predict(mmModel) ~ time_frame, lwd = 3, col = "dark red")
?nls
mmModel.formula
mmModel$m
mmModel$data
mmModel$call
mmModel$control
Summary(mmModel)
summary(mmModel)
diff(mmModel)
AIC(mmModel)
library(ggplot2)
# finding local maxima, potentiel knee points
which(diff(sign(diff(ratioData)))==-2)+1
# finding local maxima, potentiel knee points
length(which(diff(sign(diff(ratioData)))==-2)+1)
# finding the linear fit from origo to asymptote
a_linearFit <- max(ratioData) / length(ratioData)
min(ratioData)
min(time_frame)
# finding the linear fit from origo to asymptote
a_linearFit <- max(ratioData) / length(time_frame)
is(length(ratioData) == length(time_frame))
length(ratioData) == length(time_frame)
b_linearFit <- min(ratioData) - a_linearFit*min(time_frame)
# finding local maxima, potentiel knee points
kneePoints_collected <- which(diff(sign(diff(ratioData)))==-2)+1
# parameters estimated including confidence interval
coef(mmModel)
# parameters estimated including confidence interval
coef(mmModel)[1]
# parameters estimated including confidence interval
coef(mmModel)[[1]]
# updating to estimated parameters
Vmax = coef(mmModel)[[1]]
K    = coef(mmModel)[[2]]
K
# using distance formular on all knee points to line
# distance formula: d = abs(a*x+b-y)/sqrt(a^2+1)
longest_distance <- 0
for (i in kneePoints_collected) {
temp_x = i
temp_y = Vmax*temp_x / (K*temp_x)
dist = abs(a_linearFit*temp_x + b_linearFit-temp_y)/sqrt(a_linearFit^2+1)
if (dist >= longest_distance) {longest_distance = dist}
}
longest_distance
# using distance formular on all knee points to line
# distance formula: d = abs(a*x+b-y)/sqrt(a^2+1)
longest_distance  <- 0
longest_x         <- 0
for (i in kneePoints_collected) {
temp_x = i
temp_y = Vmax*temp_x / (K*temp_x)
dist = abs(a_linearFit*temp_x + b_linearFit-temp_y)/sqrt(a_linearFit^2+1)
if (dist >= longest_distance) {longest_distance = dist; longest_x = temp_x}
}
longest_x
length(ratioData)
for (i in kneePoints_collected) {
temp_x = i
temp_y = Vmax*temp_x / (K*temp_x)
dist = abs(a_linearFit*temp_x + b_linearFit-temp_y)/sqrt(a_linearFit^2+1)
print(dist)
if (dist >= longest_distance) {longest_distance = dist; longest_x = temp_x}
}
kneePoints_collected
temp <- 0
for (i in kneePoints_collected) {
temp_x = i
temp_y = Vmax*temp_x / (K*temp_x)
dist = abs(a_linearFit*temp_x + b_linearFit-temp_y)/sqrt(a_linearFit^2+1)
print(dist)
if (dist >= longest_distance) {longest_distance = dist; longest_x = temp_x}
temp = temp+1
print(temp)
}
for (i in kneePoints_collected) {
temp_x = i
temp_y = Vmax*temp_x / (K*temp_x)
dist = abs(a_linearFit*temp_x + b_linearFit-temp_y)/sqrt(a_linearFit^2+1)
print(dist)
if (dist >= longest_distance) {longest_distance = dist; longest_x = temp_x}
}
longest_x
ratioData[longest_x]
# visualizing the model in relation to ratio Data
plot(sort(ratioData) ~ time_frame, col = "grey")
lines(predict(mmModel) ~ time_frame, lwd = 3, col = "dark red")
abline(h = 0.51111)
cutOff <- ratioData[longest_x]
plot(ratioData)
# defining the cutoff threshold
threshold_ratio <- ratioData[longest_x]
which(ratioData > threshold_ratio)
length(which(ratioData > threshold_ratio))
length(ratioData)
length(which(ratioData > threshold_ratio))-length(ratioData)
plot(sort(ratioData))
?sign
which(ratioData <= threshold_ratio)
# if the ratioData is above the found cutoff, it is to be removed
throwAway <- which(ratioData <= threshold_ratio)
# dropping columns by index
inData = inData[, throwAway]
rm(throwAway) # to save memory
outData = inData
outData = inData
library(gsubfn)
rm(list=setdiff(ls(), c"outData", "testID", "OUA"))
rm(list=setdiff(ls(), c"outData", "testID", "OUA"))
rm(list=setdiff(ls(), c"outData", "testID", "OUA"))
rm(list=setdiff(ls(), c("outData", "testID", "OUA")))
source("C:/Users/Jmoll/Documents/GitHub/Coupling-of-omics-data/Programming/data_filtering.R")
list[data, testID, OUA]       <- data_filtering(data = data)
list[data, testID, OUA]       <- data_filtering(data)
source("C:/Users/Jmoll/Documents/GitHub/Coupling-of-omics-data/Programming/data_filtering.R")
# loading in the data
list[data, len_16s, len_qpcr] <- extracting_data_KAT()
list[data, testID, OUA]       <- data_filtering(data)
setwd("~/GitHub/Coupling-of-omics-data")
# loading libraries
library(vegan)
# loading functions
source("Programming/extracting_data_NATH.R")
source("Programming/data_filtering.R")
source("Programming/data_analyze.R")
# loading NetCoMi library
library(NetCoMi)
if(!requireNamespace("BiocManager", quietly = TRUE)){
utils::install.packages("BiocManager")
}
BiocManager::install(pkgs = c("Biobase", "doSNOW", "fdrtool", "filematrix",
"foreach", "graphics", "grDevices", "gtools",
"huge", "igraph", "MASS", "Matrix", "phyloseq",
"pulsar", "qgraph", "Rdpack", "snow", "SPRING",
"stats", "utils", "vegan", "WGCNA"))
BiocManager::install("GO.db")
devtools::install_github("GraceYoon/SPRING")
install.packages("devtools")
# install.packages("devtools")
devtools::install_github("GraceYoon/SPRING")
devtools::install_github("zdk123/SpiecEasi")
devtools::install_github("stefpeschel/NetCoMi",
dependencies = c("Depends", "Imports"),
repos = c("https://cloud.r-project.org/",
BiocManager::repositories()))
rm(list=ls())
# loading NetCoMi library
library(NetCoMi)
devtools::install_github("stefpeschel/NetCoMi",
dependencies = c("Depends", "Imports"),
repos = c("https://cloud.r-project.org/",
BiocManager::repositories()))
# loading NetCoMi library
library(NetCoMi)
# loading libraries
library(vegan)
# loading functions
source("Programming/extracting_data_NATH.R")
source("Programming/data_filtering.R")
source("Programming/data_analyze.R")
tmp <- data(dune)
View(dune)
dat <- expand.grid(rep=gl(2,1), NO3=factor(c(0,10)),field=gl(3,1) )
View(dat)
# loading in data
df_metab_original <- read.csv("Data/allData_LCMS_metabolomics.csv", header = FALSE,
sep = ";", stringsAsFactors = FALSE, strip.white = TRUE, skip = 1)
colnames(df_metab_original) = read.csv("Data/allData_LCMS_metabolomics.csv", header = F,
sep = ";", stringsAsFactors = FALSE, strip.white = TRUE, nrows = 1)
rownames(df_metab_original) = read.csv("Data/allData_LCMS_metabolomics.csv", header = F,
sep = ";", stringsAsFactors = FALSE, strip.white = TRUE)[-1,1]
# removing first column (masses)
df_metab_original = df_metab_original[,-1]
# transposing the data frame
df_metab_tmp1 = as.data.frame(t(df_metab_original))
# loading in metadata metabolomics sheet - changed data to .csv first, to make it work
metadata_metabolomics  <- read.csv("Data/Metadata-metabolomics.csv", fill = TRUE, header = TRUE, sep = ";")
# fetching first row
rownam_samples_metab  <- rownames(df_metab_tmp1)
# running through the names, matching them with phyloseq naming
metab_new_names <- rownam_samples_metab
strata_field    <- rownam_samples_metab
source("Programming/Functions.R")
source("Programming/Functions.R")
# loading libraries
library(vegan)
rm(list=ls())
# loading libraries
library(vegan)
library(gsubfn)
# loading functions
source("Programming/extracting_data_NATH.R")
source("Programming/data_filtering.R")
# loading in metadata metabolomics sheet - changed data to .csv first, to make it work
metadata_metabolomics  <- read.csv("Data/Metadata-metabolomics.csv", fill = TRUE, header = TRUE, sep = ";")
# fetching first row
rownam_samples_metab  <- rownames(df_metab_tmp1)
# running through the names, matching them with phyloseq naming
metab_new_names <- rownam_samples_metab
# loading functions
source("Programming/extracting_data_NATH.R")
source("Programming/data_filtering.R")
source("Programming/data_analyze.R")
source("Programming/Functions.R")
list(data_metab, strata_field) <- getMetabDataNormEval(cutOffMetabMass = 200, whichNormalization = "peak")
rm(metadata_metabolomics)
list(data_metab, strata_field) <- getMetabDataNormEval(cutOffMetabMass = 200, whichNormalization = "peak")
list(inData, strata_field) <- getMetabDataNormEval(cutOffMetabMass = 200, whichNormalization = "peak")
list[inData, strata_field] <- getMetabDataNormEval(cutOffMetabMass = 200, whichNormalization = "peak")
strata_field
strata_field    <- array(0, length(metab_new_names))
# loading in metadata metabolomics sheet - changed data to .csv first, to make it work
metadata_metabolomics  <- read.csv("Data/Metadata-metabolomics.csv", fill = TRUE, header = TRUE, sep = ";")
# fetching first row
rownam_samples_metab  <- rownames(df_metab_tmp1)
# running through the names, matching them with phyloseq naming
metab_new_names <- rownam_samples_metab
strata_field    <- array(0, length(metab_new_names))
df_metab_original <- read.csv("Data/allData_LCMS_metabolomics.csv", header = FALSE,
sep = ";", stringsAsFactors = FALSE, strip.white = TRUE, skip = 1)
colnames(df_metab_original) = read.csv("Data/allData_LCMS_metabolomics.csv", header = F,
sep = ";", stringsAsFactors = FALSE, strip.white = TRUE, nrows = 1)
rownames(df_metab_original) = read.csv("Data/allData_LCMS_metabolomics.csv", header = F,
sep = ";", stringsAsFactors = FALSE, strip.white = TRUE)[-1,1]
# removing first column (masses)
df_metab_original = df_metab_original[,-1]
# transposing the data frame
df_metab_tmp1 = as.data.frame(t(df_metab_original))
# loading in metadata metabolomics sheet - changed data to .csv first, to make it work
metadata_metabolomics  <- read.csv("Data/Metadata-metabolomics.csv", fill = TRUE, header = TRUE, sep = ";")
# fetching first row
rownam_samples_metab  <- rownames(df_metab_tmp1)
# running through the names, matching them with phyloseq naming
metab_new_names <- rownam_samples_metab
strata_field    <- array(0, length(metab_new_names))
rm(list=ls())
# loading libraries
library(vegan)
library(gsubfn)
# loading functions
source("Programming/extracting_data_NATH.R")
source("Programming/data_filtering.R")
source("Programming/data_analyze.R")
source("Programming/Functions.R")
list[inData, strata_field] <- getMetabDataNormEval(cutOffMetabMass = 200, whichNormalization = "peak")
strata_field
source("Programming/Functions.R")
list[inData, strata_field] <- getMetabDataNormEval(cutOffMetabMass = 200, whichNormalization = "peak")
list[data_peak, strata_field]   <- getMetabDataNormEval(cutOffMetabMass = 200, whichNormalization = "peak")
list[data_median, strata_field] <- getMetabDataNormEval(cutOffMetabMass = 200, whichNormalization = "median")
list[data_mad, strata_field]    <- getMetabDataNormEval(cutOffMetabMass = 200, whichNormalization = "mad")
View(data_mad)
View(data_median)
View(data_peak)
rm(list=ls())
library(vegan)
data(dune)
data(dune.env)
adonis(dune ~ Management*A1, data=dune.env, permutations=99)
View(dune)
View(dune.env)
dat <- expand.grid(rep=gl(2,1), NO3=factor(c(0,10)),field=gl(3,1) )
dat
Agropyron <- with(dat, as.numeric(field) + as.numeric(NO3)+2) +rnorm(12)/2
Agropyron
Schizachyrium <- with(dat, as.numeric(field) - as.numeric(NO3)+2) +rnorm(12)/2
total <- Agropyron + Schizachyrium
total
dotplot(total ~ NO3, dat, jitter.x=TRUE, groups=field,
type=c('p','a'), xlab="NO3", auto.key=list(columns=3, lines=TRUE) )
Y <- data.frame(Agropyron, Schizachyrium)
Y
mod
mod <- metaMDS(Y)
### Hulls show treatment
with(dat, ordihull(mod, group=NO3, show="0"))
plot(mod)
### Hulls show treatment
with(dat, ordihull(mod, group=NO3, show="0"))
with(dat, ordihull(mod, group=NO3, show="10", col=3))
### Spider shows fields
with(dat, ordispider(mod, group=field, lty=3, col="red"))
View(dat)
### Correct hypothesis test (with strata)
adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
### Incorrect (no strata)
adonis(Y ~ NO3, data=dat, perm=999)
### Correct hypothesis test (with strata)
adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
### Correct hypothesis test (with strata)
tmp <- adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
tmp$coefficients
summary(tmp)
View(tmp)
dat
View(dune)
View(dune.env)
# loading functions
source("Programming/extracting_data_NATH.R")
source("Programming/data_filtering.R")
source("Programming/data_analyze.R")
source("Programming/Functions.R")
library(gsubfn)
# getting the data
list[data_peak, strata_field]   <- getMetabDataNormEval(cutOffMetabMass = 200, whichNormalization = "peak")
list[data_median, strata_field] <- getMetabDataNormEval(cutOffMetabMass = 200, whichNormalization = "median")
list[data_mad, strata_field]    <- getMetabDataNormEval(cutOffMetabMass = 200, whichNormalization = "mad")
# adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
adonis(data_peak ~ strata_field, strata = strata_field, permutations = 100)
# adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
adonis2(data_peak ~ strata_field, strata = strata_field, permutations = 100)
# adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
adonis2(data_peak ~ strata_field, strata = strata_field, permutations = 100, by = NULL)
# adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
adonis2(data_peak ~ strata_field, strata = strata_field, permutations = 100, by = "margin")
# adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
adonis2(data_peak ~ strata_field, strata = strata_field, permutations = 100, by = "terms")
# adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
adonis2(data_peak ~ strata_field, strata = strata_field, permutations = 100, by = NULL)
# adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
adonis2(data_peak ~ strata_field, strata = strata_field, permutations = 1000, by = NULL)
adonis2(data_median ~ strata_field, strata = strata_field, permutations = 1000, by = NULL)
adonis2(data_mad ~ strata_field, strata = strata_field, permutations = 1000, by = NULL)
strata_field
length(which(strata_field == 1))
length(which(strata_field == 2))
length(which(strata_field == 3))
length(which(strata_field == 4))
View(data_median)
# adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
ado_peak <- adonis2(data_peak ~ strata_field, strata = strata_field, permutations = 1000, by = NULL)
ado_peak
ado_peak$Df
ado_peak$SumOfSqs
ado_peak$`Pr(>F)`
ado_peak$F
# adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
ado_peak <- adonis1(data_peak ~ strata_field, strata = strata_field, permutations = 1000, by = NULL)
# adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
ado_peak <- adonis(data_peak ~ strata_field, strata = strata_field, permutations = 1000, by = NULL)
ado_peak$aov.tab
ado_peak$call$formula
ado_peak$call$permutations
ado_peak$f.perms
ado_peak$coefficients
ado_peak$coef.sites
ado_peak$model.matrix
ado_peak$terms
adonis2(data_median ~ strata_field, strata = strata_field, permutations = 1000, by = NULL)
adonis2(data_median ~ strata_field, strata = strata_field, permutations = 999, by = NULL)
?dist
dist_median <- dist(data_median, method = "euclidean")
adonis2(dist_median ~ strata_field, strata = strata_field, permutations = 999, by = NULL)
dist_median <- as.data.frame(dist(data_median, method = "euclidean"))
dist_median <- as.matrix(dist(data_median, method = "euclidean"))
View(dist_median)
adonis2(dist_median ~ strata_field, strata = strata_field, permutations = 999, by = NULL)
adonis2(data_median ~ strata_field, strata = strata_field, permutations = 999, by = NULL)
dist_median <- as.matrix(dist(data_median, method = "euclidean"))
as.dist(dist_median)
here <- as.dist(dist_median)
# loading data
chosenDataSet       = "metab"       # "metab" or "genom"
chosenTaxonomy      <- "species"    # "species" or "genus"
chosenWeek          <- "null"       # "1", "4", or "10"
chosenCutoffMass    <- 300          # arbitrary value, removing based on column name
chosenNormalization <- "mad"        # can either be 'mad', 'median' or 'peak'
inData <- extracting_data_NATH(whichWeek=chosenWeek, whichTaxLevel=chosenTaxonomy,
cutOffMetabMass=chosenCutoffMass, whichNormalization=chosenNormalization)
# filtering data
chosenCutoffFiltering <- 0.9
inData <- data_filtering(data=inData, whichDataSet=chosenDataSet, whichWeek=chosenWeek, cutOffOrAuto=chosenCutoffFiltering)
# adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
adonis(data_peak ~ strata_field, strata = NULL, permutations = 999, by = NULL)
# adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
adonis2(data_peak ~ strata_field, strata = NULL, permutations = 999, by = NULL)
# adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
adonis2(data_peak ~ strata_field, strata = strata_field, permutations = 999, by = NULL)
# adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
adonis2(data_peak ~ strata_field, strata = strata_field, permutations = 999, by = NULL, method = "euclidean")
adonis2(data_median ~ strata_field, strata = strata_field, permutations = 999, by = NULL)
adonis2(data_median ~ strata_field, strata = NULL, permutations = 999, by = NULL)
# loading libraries
library(vegan)
library(gsubfn)
# loading functions
source("Programming/extracting_data_NATH.R")
source("Programming/data_filtering.R")
source("Programming/data_analyze.R")
source("Programming/Functions.R")
# getting the data
list[data_peak, strata_field]   <- getMetabDataNormEval(cutOffMetabMass = 200, whichNormalization = "peak")
list[data_median, strata_field] <- getMetabDataNormEval(cutOffMetabMass = 200, whichNormalization = "median")
list[data_mad, strata_field]    <- getMetabDataNormEval(cutOffMetabMass = 200, whichNormalization = "mad")
# adonis(Y ~ NO3, data=dat, strata=dat$field, perm=999)
adonis2(data_peak ~ strata_field, strata = strata_field, permutations = 999, by = NULL, method = "euclidean")
adonis2(data_median ~ strata_field, strata = NULL, permutations = 999, by = NULL)
adonis2(data_mad ~ strata_field, strata = strata_field, permutations = 999, by = NULL)
adonis2(data_mad ~ strata_field, strata = strata_field, permutations = 999, by = NULL)
adonis(data_mad ~ strata_field, strata = strata_field, permutations = 999, by = NULL)
adonis2(data_median ~ strata_field, strata = strata_field, permutations = 999, by = NULL)
ad_median <- adonis(data_median ~ strata_field, strata = strata_field, permutations = 999, by = NULL)
View(ad_median)
ad_median <- adonis(sort(data_median, x = strata_field) ~ sort(strata_field), strata = sort(strata_field), permutations = 999, by = NULL)
ad_median <- adonis(data_median[sort(strata_field, decreasing = F)] ~ sort(strata_field), strata = sort(strata_field), permutations = 999, by = NULL)
ad_median <- adonis2(data_median[sort(strata_field, decreasing = F)] ~ sort(strata_field), strata = sort(strata_field), permutations = 999, by = NULL)
ad_median
adonis2(data_mad ~ strata_field, strata = strata_field, permutations = 999, by = NULL)
adonis2(data_mad ~ strata_field, strata = NULL, permutations = 999, by = NULL)
# loading NetCoMi library
library(NetCoMi)
# loading functions
source("Programming/extracting_data_NATH.R")
source("Programming/data_filtering.R")
source("Programming/data_analyze.R")
# loading data
chosenDataSet       = "metab"       # "metab" or "genom"
chosenTaxonomy      <- "species"    # "species" or "genus"
chosenWeek          <- "null"       # "1", "4", or "10"
chosenCutoffMass    <- 300          # arbitrary value, removing based on column name
chosenCutoffMass    <- 200          # arbitrary value, removing based on column name
chosenNormalization <- "mad"        # can either be 'mad', 'median' or 'peak'
inData <- extracting_data_NATH(whichWeek=chosenWeek, whichTaxLevel=chosenTaxonomy,
cutOffMetabMass=chosenCutoffMass, whichNormalization=chosenNormalization)
# filtering data
chosenCutoffFiltering <- 0.9
inData <- data_filtering(data=inData, whichDataSet=chosenDataSet, whichWeek=chosenWeek, cutOffOrAuto=chosenCutoffFiltering)
# filtering data
chosenCutoffFiltering <- 0.85
inData <- data_filtering(data=inData, whichDataSet=chosenDataSet, whichWeek=chosenWeek, cutOffOrAuto=chosenCutoffFiltering)
inData <- extracting_data_NATH(whichWeek=chosenWeek, whichTaxLevel=chosenTaxonomy,
cutOffMetabMass=chosenCutoffMass, whichNormalization=chosenNormalization)
# filtering data
chosenCutoffFiltering <- 0.85
inData <- data_filtering(data=inData, whichDataSet=chosenDataSet, whichWeek=chosenWeek, cutOffOrAuto=chosenCutoffFiltering)
# can only select week number 1, 4, 6, or 10
choiceOfWeekHere <- "null"
if (choiceOfWeekHere != "null") {
data = inData[gsub(".+-(?=\\d+$)", "", rownames(inData), perl = TRUE)==choiceOfWeekHere,]
} else {
data = inData
}
if (chosenTaxonomy=="genus"){
colnames(data)=gsub("DATA.Bacteria_[A-Za-z]*[_.][A-Za-z]*[_.][A-Za-z]*[_.][A-Za-z]*[_.](.*)","\\1",colnames(data))
colnames(data)=gsub("DATA.Archaea_[A-Za-z]*[_.][A-Za-z]*[_.][A-Za-z]*[_.][A-Za-z]*[_.](.*)","\\1",colnames(data))
} else {
colnames(data)=gsub("DATA.Bacteria_[A-Za-z]*[_.][A-Za-z]*[_.][A-Za-z]*[_.][A-Za-z]*[_.](.*)[_.](.*)","\\1",colnames(data))
colnames(data)=gsub("DATA.Archaea_[A-Za-z]*[_.][A-Za-z]*[_.][A-Za-z]*[_.][A-Za-z]*[_.](.*)[_.](.*)","\\1",colnames(data))
}
############################
# compare two networks differentiated upon presence of TDA or not
# splitting the data set of all weeks into three; TDA, noTDA and control
data_TDA      <- data[substr(rownames(data), 1, 1) == "D",]
data_noTDA    <- data[substr(rownames(data), 1, 1) == "P",]
data_control  <- data[substr(rownames(data), 1, 1) == "C",]
# Network construction
net_TDA <- netConstruct(data = data_noTDA,
data2 = data_control,
filtTax = "highestVar",
filtTaxPar = list(highestVar = 50),
measure = "spearman", thresh = 0.5,
measurePar = list(nlambda=10,
rep.num=10),
normMethod = "none",
zeroMethod = "none",
sparsMethod = "threshold",
dissFunc = "signed",
verbose = 3, weighted = T,
seed = 123456)
props_TDA <- netAnalyze(net_TDA,
centrLCC = FALSE,
avDissIgnoreInf = TRUE,
sPathNorm = FALSE,
clustMethod = "cluster_fast_greedy",
#hubPar = c("degree", "between", "closeness"),
hubPar = "eigenvector",
hubQuant = 0.9,
lnormFit = TRUE,
normDeg = FALSE,
normBetw = FALSE,
normClose = FALSE,
normEigen = FALSE)
summary(props_TDA)
plot(props_TDA,
sameLayout = TRUE,
nodeColor = "cluster",
nodeSize = "mclr",
labelScale = FALSE,
shortenLabels = "none",
cexNodes = 1.5,
cexLabels = 1.3,
cexHubLabels = 1,
cexTitle = 3.7,
groupNames = c("No TDA", "Control"),
hubBorderCol  = "gray40")
