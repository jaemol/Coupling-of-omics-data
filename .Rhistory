library(pbkrtest)
library(ggplot2)
library(ggpubr)
library(factoextra) # used to create ggplot2-based visualization
library(data.table) # used to keep structure of data frame when transposing
# excluding testID and OUA (antibiotics used or not)
inData = data
testID  <- inData$testID
OUA     <- inData$OUA
inData = subset(inData, select = -c(testID, OUA))
# adding the names to the transposed data
#rownames(inData) <- colnames(data[-(1:2)])
rownames(inData) <- testID
# making PCA model
pcaModel <- prcomp(inData, scale = TRUE)
# making scree plot, to visualize eigenvalues
fviz_eig(pcaModel)
# making a graph of the variables
# visualizing the correlation between the variables
# positive correlated variables point to the same side of the plot
# negative correlated variables point to opposite sides of the plot
fviz_pca_var(pcaModel,
col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = FALSE     # Avoid text overlapping
#,select.var = list(name = rownames(inData))
)
# excluding testID and OUA (antibiotics used or not)
inData = data
testID  <- inData$testID
OUA     <- inData$OUA
inData = subset(inData, select = -c(testID, OUA))
# transposing data; samples on columns, features on rows
inData = transpose(inData)
# adding the names to the transposed data
rownames(inData) <- colnames(data[-(1:2)])
colnames(inData) <- testID
# making PCA model
pcaModel <- prcomp(inData, scale = TRUE)
# making scree plot, to visualize eigenvalues
fviz_eig(pcaModel)
# making a graph of the variables
# visualizing the correlation between the variables
# positive correlated variables point to the same side of the plot
# negative correlated variables point to opposite sides of the plot
fviz_pca_var(pcaModel,
col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = FALSE     # Avoid text overlapping
#,select.var = list(name = rownames(inData))
)
# making PCA model
pcaModel <- prcomp(t(inData), scale = TRUE)
# making scree plot, to visualize eigenvalues
fviz_eig(pcaModel)
# making a graph of the variables
# visualizing the correlation between the variables
# positive correlated variables point to the same side of the plot
# negative correlated variables point to opposite sides of the plot
fviz_pca_var(pcaModel,
col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = FALSE     # Avoid text overlapping
#,select.var = list(name = rownames(inData))
)
# making PCA model
pcaModel <- prcomp(t(inData[,1:20]), scale = TRUE)
# making scree plot, to visualize eigenvalues
fviz_eig(pcaModel)
# making a graph of the variables
# visualizing the correlation between the variables
# positive correlated variables point to the same side of the plot
# negative correlated variables point to opposite sides of the plot
fviz_pca_var(pcaModel,
col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = FALSE     # Avoid text overlapping
#,select.var = list(name = rownames(inData))
)
# making PCA model
pcaModel <- prcomp(t(inData[,1:10]), scale = TRUE)
# making scree plot, to visualize eigenvalues
fviz_eig(pcaModel)
# making a graph of the variables
# visualizing the correlation between the variables
# positive correlated variables point to the same side of the plot
# negative correlated variables point to opposite sides of the plot
fviz_pca_var(pcaModel,
col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = FALSE     # Avoid text overlapping
#,select.var = list(name = rownames(inData))
)
# making PCA model
pcaModel <- prcomp(t(inData[,1:11]), scale = TRUE)
# making scree plot, to visualize eigenvalues
fviz_eig(pcaModel)
# making a graph of the variables
# visualizing the correlation between the variables
# positive correlated variables point to the same side of the plot
# negative correlated variables point to opposite sides of the plot
fviz_pca_var(pcaModel,
col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = FALSE     # Avoid text overlapping
#,select.var = list(name = rownames(inData))
)
# making PCA model
pcaModel <- prcomp(t(inData[1:10,]), scale = TRUE)
# making scree plot, to visualize eigenvalues
fviz_eig(pcaModel)
# making a graph of the variables
# visualizing the correlation between the variables
# positive correlated variables point to the same side of the plot
# negative correlated variables point to opposite sides of the plot
fviz_pca_var(pcaModel,
col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = FALSE     # Avoid text overlapping
#,select.var = list(name = rownames(inData))
)
plot(pcaModel$x[,1], pcaModel$x[,2])
plot(pcaModel$x[,1], pcaModel$x[,3])
plot(pcaModel$x[,1], pcaModel$x[,3])
plot(pcaModel$x[,1], pcaModel$x[,2])
plot(pcaModel$x[,1], pcaModel$x[,3])
# making PCA model
pcaModel <- prcomp(t(inData), scale = TRUE)
# making scree plot, to visualize eigenvalues
fviz_eig(pcaModel)
# making a graph of the variables
# visualizing the correlation between the variables
# positive correlated variables point to the same side of the plot
# negative correlated variables point to opposite sides of the plot
fviz_pca_var(pcaModel,
col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = FALSE     # Avoid text overlapping
#,select.var = list(name = rownames(inData))
)
plot(pcaModel$x[,1], pcaModel$x[,2])
plot(pcaModel$x[,1], pcaModel$x[,3])
# adding the names to the transposed data
#rownames(inData) <- colnames(data[-(1:2)])
#colnames(inData) <- testID
rownames(inData) <- testID
# excluding testID and OUA (antibiotics used or not)
inData = data
testID  <- inData$testID
OUA     <- inData$OUA
inData = subset(inData, select = -c(testID, OUA))
# adding the names to the transposed data
#rownames(inData) <- colnames(data[-(1:2)])
#colnames(inData) <- testID
rownames(inData) <- testID
# making PCA model
pcaModel <- prcomp(t(inData), scale = TRUE)
# making scree plot, to visualize eigenvalues
fviz_eig(pcaModel)
plot(pcaModel$x[,1], pcaModel$x[,2])
plot(pcaModel$x[,1], pcaModel$x[,3])
# making PCA model
pcaModel <- prcomp(inData, scale = TRUE)
# making scree plot, to visualize eigenvalues
fviz_eig(pcaModel)
plot(pcaModel$x[,1], pcaModel$x[,2])
plot(pcaModel$x[,1], pcaModel$x[,3])
# making a graph of the variables
# visualizing the correlation between the variables
# positive correlated variables point to the same side of the plot
# negative correlated variables point to opposite sides of the plot
fviz_pca_var(pcaModel,
col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = FALSE     # Avoid text overlapping
#,select.var = list(name = rownames(inData))
)
# making scree plot, to visualize eigenvalues
fviz_eig(pcaModel)
####################################
pca <- prcomp((inData), scale=TRUE)
## plot pc1 and pc2
plot(pca$x[,1], pca$x[,2])
## make a scree plot
pca.var <- pca$sdev^2
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)
barplot(pca.var.per, main="Scree Plot", xlab="Principal Component", ylab="Percent Variation")
## now make a fancy looking plot that shows the PCs and the variation:
library(ggplot2)
pca.data <- data.frame(Sample=rownames(pca$x),
X=pca$x[,1],
Y=pca$x[,2])
pca.data
View(inData)
# excluding testID and OUA (antibiotics used or not)
inData = data
testID  <- inData$testID
OUA     <- inData$OUA
inData = subset(inData, select = -c(testID, OUA))
####################################
pca <- prcomp((inData), scale=TRUE)
## plot pc1 and pc2
plot(pca$x[,1], pca$x[,2])
## make a scree plot
pca.var <- pca$sdev^2
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)
barplot(pca.var.per, main="Scree Plot", xlab="Principal Component", ylab="Percent Variation")
## now make a fancy looking plot that shows the PCs and the variation:
library(ggplot2)
pca.data <- data.frame(Sample=rownames(pca$x),
X=pca$x[,1],
Y=pca$x[,2])
pca.data
# adding the names to the transposed data
#rownames(inData) <- colnames(data[-(1:2)])
#colnames(inData) <- testID
rownames(inData) <- testID
# excluding testID and OUA (antibiotics used or not)
inData = data
testID  <- inData$testID
OUA     <- inData$OUA
inData = subset(inData, select = -c(testID, OUA))
# adding the names to the transposed data
#rownames(inData) <- colnames(data[-(1:2)])
#colnames(inData) <- testID
rownames(inData) <- testID
####################################
pca <- prcomp((inData), scale=TRUE)
## plot pc1 and pc2
plot(pca$x[,1], pca$x[,2])
## make a scree plot
pca.var <- pca$sdev^2
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)
barplot(pca.var.per, main="Scree Plot", xlab="Principal Component", ylab="Percent Variation")
## now make a fancy looking plot that shows the PCs and the variation:
library(ggplot2)
pca.data <- data.frame(Sample=rownames(pca$x),
X=pca$x[,1],
Y=pca$x[,2])
pca.data
ggplot(data=pca.data, aes(x=X, y=Y, label=Sample)) +
geom_text() +
xlab(paste("PC1 - ", pca.var.per[1], "%", sep="")) +
ylab(paste("PC2 - ", pca.var.per[2], "%", sep="")) +
theme_bw() +
ggtitle("My PCA Graph")
## get the name of the top 10 measurements (genes) that contribute
## most to pc1.
loading_scores <- pca$rotation[,1]
gene_scores <- abs(loading_scores) ## get the magnitudes
gene_score_ranked <- sort(gene_scores, decreasing=TRUE)
top_10_genes <- names(gene_score_ranked[1:10])
top_10_genes ## show the names of the top 10 genes
pca$rotation[top_10_genes,1] ## show the scores (and +/- sign)
## get the name of the top 10 measurements (genes) that contribute
## most to pc1.
loading_scores <- pca$rotation[,1:2]
gene_scores <- abs(loading_scores) ## get the magnitudes
gene_score_ranked <- sort(gene_scores, decreasing=TRUE)
top_10_genes <- names(gene_score_ranked[1:10])
top_10_genes ## show the names of the top 10 genes
pca$rotation[top_10_genes,1] ## show the scores (and +/- sign)
## get the name of the top 10 measurements (genes) that contribute
## most to pc1.
loading_scores <- pca$rotation[,2]
gene_scores <- abs(loading_scores) ## get the magnitudes
gene_score_ranked <- sort(gene_scores, decreasing=TRUE)
top_10_genes <- names(gene_score_ranked[1:10])
top_10_genes ## show the names of the top 10 genes
pca$rotation[top_10_genes,1] ## show the scores (and +/- sign)
## get the name of the top 10 measurements (genes) that contribute
## most to pc1.
loading_scores <- pca$rotation[,1]
gene_scores <- abs(loading_scores) ## get the magnitudes
gene_score_ranked <- sort(gene_scores, decreasing=TRUE)
top_10_genes <- names(gene_score_ranked[1:10])
top_10_genes ## show the names of the top 10 genes
pca$rotation[top_10_genes,1] ## show the scores (and +/- sign)
sum(pca.var.per[1:10])
sum(pca.var.per[1:50])
sum(pca.var.per[1:60])
sum(pca.var.per[1:100])
sum(pca.var.per[1:90])
sum(pca.var.per[1:87])
sum(pca.var.per[1:80])
sum(pca.var.per[1:75])
sum(pca.var.per[1:60])
sum(pca.var.per[1:68])
sum(pca.var.per[1:69])
?prcomp
# making PCA model
pcaModel <- prcomp(inData, center = TRUE, scale = TRUE)
# making scree plot, to visualize eigenvalues
fviz_eig(pcaModel)
####################################
pca <- prcomp((inData), center = TRUE, scale=TRUE)
## plot pc1 and pc2
plot(pca$x[,1], pca$x[,2])
## make a scree plot
pca.var <- pca$sdev^2
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)
barplot(pca.var.per, main="Scree Plot", xlab="Principal Component", ylab="Percent Variation")
## now make a fancy looking plot that shows the PCs and the variation:
library(ggplot2)
pca.data <- data.frame(Sample=rownames(pca$x),
X=pca$x[,1],
Y=pca$x[,2])
pca.data
ggplot(data=pca.data, aes(x=X, y=Y, label=Sample)) +
geom_text() +
xlab(paste("PC1 - ", pca.var.per[1], "%", sep="")) +
ylab(paste("PC2 - ", pca.var.per[2], "%", sep="")) +
theme_bw() +
ggtitle("My PCA Graph")
## get the name of the top 10 measurements (genes) that contribute
## most to pc1.
loading_scores <- pca$rotation[,1]
gene_scores <- abs(loading_scores) ## get the magnitudes
gene_score_ranked <- sort(gene_scores, decreasing=TRUE)
top_10_genes <- names(gene_score_ranked[1:10])
top_10_genes ## show the names of the top 10 genes
pca$rotation[top_10_genes,1] ## show the scores (and +/- sign)
barplot(pca.var.per, main="Scree Plot", xlab="Principal Component", ylab="Percent Variation")
abline(h=1/ncol(inData)*100, col='red')
# making scree plot, to visualize eigenvalues
fviz_eig(pcaModel)
abline(h=1/ncol(inData)*100, col='red')
## get the name of the top 10 measurements (genes) that contribute
## most to pc1.
loading_scores <- pca$rotation[,1]
####################################
pca <- prcomp((inData), scale=TRUE)
## plot pc1 and pc2
plot(pca$x[,1], pca$x[,2])
## make a scree plot
pca.var <- pca$sdev^2
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)
plot(pca$x[,1], pca$x[,3])
## make a scree plot
pca.var <- pca$sdev^2
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)
barplot(pca.var.per, main="Scree Plot", xlab="Principal Component", ylab="Percent Variation")
abline(h=1/ncol(inData)*100, col='red')
# other way! - making scree plot, to visualize eigenvalues
fviz_eig(pcaModel)
## now make a fancy looking plot that shows the PCs and the variation:
library(ggplot2)
pca.data <- data.frame(Sample=rownames(pca$x),
X=pca$x[,1],
Y=pca$x[,2])
pca.data
ggplot(data=pca.data, aes(x=X, y=Y, label=Sample)) +
geom_text() +
xlab(paste("PC1 - ", pca.var.per[1], "%", sep="")) +
ylab(paste("PC2 - ", pca.var.per[2], "%", sep="")) +
theme_bw() +
ggtitle("My PCA Graph")
## get the name of the top 10 measurements (genes) that contribute
## most to pc1.
loading_scores <- pca$rotation[,1]
gene_scores <- abs(loading_scores) ## get the magnitudes
gene_score_ranked <- sort(gene_scores, decreasing=TRUE)
top_10_genes <- names(gene_score_ranked[1:10])
top_10_genes ## show the names of the top 10 genes
pca$rotation[top_10_genes,1] ## show the scores (and +/- sign)
colnames(inData[,1])
colnames(inData[1])
# excluding testID and OUA (antibiotics used or not)
inData = data
testID  <- inData$testID
OUA     <- inData$OUA
inData = subset(inData, select = -c(testID, OUA))
rownames(inData) <- testID
# selecting arbitrary cluster number, just for visualization
kmeans_model <- kmeans(inData, 3, nstart = 10)
# generating cluster
fviz_cluster(kmeans_model, inData, frame = FALSE, geom = "point")
findEpsi=function(L, minRange=0,maxRange=3, steps=0.1, maxY=200, minP=10) {
plot(0,0, col=0,xlim=c(minRange,maxRange), ylim=c(0,maxY))
legend("topright", legend = c("nClust","nOutliers"), col=1:2, pch=16)
for(i in seq(minRange,maxRange,steps)) {
DB=dbscan::dbscan(L,i,minP)
points(i,length(unique(DB$cluster)), pch=16, col=1)
points(i,length(which(DB$cluster==0)), pch=16,col=2)
#print(i)
#sprintf("clusters: %f",length(unique(DB$cluster)))
}
}
inDataScale=scale(inData, center = T, scale = T)
findEpsi(inDataScale, minRange = 0, maxRange = 65, steps = 1 ,maxY=900)
findEpsi(inDataScale, minRange = 0, maxRange = 65, steps = 1 ,maxY=50)
dbscan::dbscan(inDataScale,6,3)
# excluding testID and OUA (antibiotics used or not)
inData = data
testID  <- inData$testID
OUA     <- inData$OUA
inData = subset(inData, select = -c(testID, OUA))
inData = t(inData)
colnames(inData) <- testID
inDataScale=scale(inData, center = T, scale = T)
findEpsi(inDataScale, minRange = 0, maxRange = 65, steps = 1 ,maxY=50)
View(inData)
findEpsi(inDataScale, minRange = 0, maxRange = 65, steps = 1 ,maxY=50,minP = 5)
findEpsi(inDataScale, minRange = 0, maxRange = 105, steps = 1 ,maxY=50,minP = 5)
inDataScale=scale(inData, center = T, scale = T)
findEpsi(inDataScale, minRange = 0, maxRange = 105, steps = 1 ,maxY=50,minP = 5)
View(inDataScale)
inData = subset(inData, select = -c(testID, OUA))
# excluding testID and OUA (antibiotics used or not)
inData = data
testID  <- inData$testID
OUA     <- inData$OUA
inData = subset(inData, select = -c(testID, OUA))
inDataScale=scale(inData, center = T, scale = T)
findEpsi(t(inDataScale), minRange = 0, maxRange = 105, steps = 1 ,maxY=50,minP = 5)
findEpsi(t(inDataScale), minRange = 20, maxRange = 40, steps = .1 ,maxY=10,minP = 5)
findEpsi(t(inDataScale), minRange = 30, maxRange = 33, steps = .1 ,maxY=10,minP = 5)
findEpsi=function(L, minRange=0,maxRange=3, steps=0.1, maxY=200, minP=10) {
plot(0,0, col=0,xlim=c(minRange,maxRange), ylim=c(0,maxY))
legend("topright", legend = c("nClust","nOutliers"), col=1:2, pch=16)
for(i in seq(minRange,maxRange,steps)) {
DB=dbscan::dbscan(L,i,minP)
points(i,length(unique(DB$cluster)), pch=16, col=1)
points(i,length(which(DB$cluster==0)), pch=16,col=2)
#print(i)
#sprintf("clusters: %f",length(unique(DB$cluster)))
}
abline(v=seq(minRange,maxRange,steps))
}
inDataScale=scale(inData, center = T, scale = T)
findEpsi(t(inDataScale), minRange = 30, maxRange = 33, steps = .1 ,maxY=10,minP = 5)
dbscan::dbscan(t(inDataScale),31.7,5)
DB=dbscan::dbscan(t(inDataScale),31.7,5)
DB$cluster
data.frame(DB$cluster, colnames(inDataScale)
)
clusVars=data.frame(DB$cluster, colnames(inDataScale))
clusVars=data.frame(Clus=DB$cluster,Vars=colnames(inDataScale))
subset(clusVars, Clus==1)
subset(clusVars, Clus==2)
subset(clusVars, Clus==3)
subset(clusVars, Clus==4)
subset(clusVars, Clus==5)
subset(clusVars, Clus==6)
subset(clusVars, Clus==7)
subset(clusVars, Clus==1)
findEpsi(t(inDataScale), minRange = 30, maxRange = 33, steps = .1 ,maxY=10,minP = 3)
findEpsi(t(inDataScale), minRange = 0, maxRange = 100, steps = .1 ,maxY=100,minP = 3)
findEpsi(t(inDataScale), minRange = 0, maxRange = 100, steps = 1 ,maxY=100,minP = 3)
findEpsi(t(inDataScale), minRange = 20, maxRange = 40, steps = 1 ,maxY=100,minP = 3)
findEpsi(t(inDataScale), minRange = 28, maxRange = 33, steps = .1 ,maxY=100,minP = 3)
findEpsi(t(inDataScale), minRange = 30, maxRange = 32, steps = .1 ,maxY=100,minP = 3)
DB=dbscan::dbscan(t(inDataScale),31.7,5)
DB=dbscan::dbscan(t(inDataScale),31.3,3)
clusVars=data.frame(Clus=DB$cluster,Vars=colnames(inDataScale))
subset(clusVars, Clus==1)
subset(clusVars, Clus==2)
subset(clusVars, Clus==3)
subset(clusVars, Clus==4)
subset(clusVars, Clus==5)
subset(clusVars, Clus==6)
subset(clusVars, Clus==7)
subset(clusVars, Clus==8)
subset(clusVars, Clus==9)
subset(clusVars, Clus==10)
subset(clusVars, Clus==0)
plot(inDataScale$DATA.Bacteria_Proteobacteria_Gammaproteobacteria_Enterobacterales_Enterobacteriaceae_Escherichia.Shigella,
inDataScale$Increp64)
inDataScale=data.frame(scale(inData, center = T, scale = T))
plot(inDataScale$DATA.Bacteria_Proteobacteria_Gammaproteobacteria_Enterobacterales_Enterobacteriaceae_Escherichia.Shigella,
inDataScale$Increp64)
plot(inData$DATA.Bacteria_Proteobacteria_Gammaproteobacteria_Enterobacterales_Enterobacteriaceae_Escherichia.Shigella,
inData$Increp64)
plot(log1p(inData$DATA.Bacteria_Proteobacteria_Gammaproteobacteria_Enterobacterales_Enterobacteriaceae_Escherichia.Shigella),
log1p(inData$Increp64))
# excluding testID and OUA (antibiotics used or not)
inData = data
testID  <- inData$testID
OUA     <- inData$OUA
inData = subset(inData, select = -c(testID, OUA))
####################################
pca <- prcomp((inData), scale=TRUE)
## plot pc1 and pc2
plot(pca$x[,1], pca$x[,2])
plot(pca$x[,1], pca$x[,3])
## make a scree plot
pca.var <- pca$sdev^2
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)
barplot(pca.var.per, main="Scree Plot", xlab="Principal Component", ylab="Percent Variation")
abline(h=1/ncol(inData)*100, col='red')
# other way! - making scree plot, to visualize eigenvalues
fviz_eig(pcaModel)
## now make a fancy looking plot that shows the PCs and the variation:
library(ggplot2)
pca.data <- data.frame(Sample=rownames(pca$x),
X=pca$x[,1],
Y=pca$x[,2])
pca.data
ggplot(data=pca.data, aes(x=X, y=Y, label=Sample)) +
geom_text() +
xlab(paste("PC1 - ", pca.var.per[1], "%", sep="")) +
ylab(paste("PC2 - ", pca.var.per[2], "%", sep="")) +
theme_bw() +
ggtitle("My PCA Graph")
## get the name of the top 10 measurements (genes) that contribute
## most to pc1.
loading_scores <- pca$rotation[,1]
gene_scores <- abs(loading_scores) ## get the magnitudes
gene_score_ranked <- sort(gene_scores, decreasing=TRUE)
top_10_genes <- names(gene_score_ranked[1:10])
top_10_genes ## show the names of the top 10 genes
pca$rotation[top_10_genes,1] ## show the scores (and +/- sign)
