# get the ODE solver and the epiR package
library(deSolve)
source('C:/Users/Jmoll/Downloads/HIVFærdigtScript.R', echo=TRUE)
rm(list=ls())
# 2.19
# stochastic matrix model
# yearly variation
ds<-numeric(1000)
for (j in 1:1000)
{
n <- c(430,140,430)
for (i in 1:100)
{
A <- matrix(0,3,3)
A[1,1] <- rnorm(1,.18,.04)
A[1,2] <- rnorm(1,.6,.13)
A[1,3] <- rnorm(1,.6,.13)
A[2,1] <- rnorm(1,.33,.09)
A[3,2] <- rnorm(1,.73,.15)
A[3,3] <- rnorm(1,.73,.15)
n <- A%*%n
}
ds[j] <- sum(n)
}
hist(log10(ds),breaks=100)
mean(ds)
# using a program to find the transmissionsrate;
TransmissionRateCalculator = function (firstWeekSick, secondWeekSick, firstWeekSusceptible, removalRate)
{
return( ( secondWeekSick - firstWeekSick + removalRate*firstWeekSick ) / ( firstWeekSick*firstWeekSusceptible ) )
}
TransmissionRateCalculator(1,3,300,1/5)
A <- matrix(0,nrow=17,ncol=17)
s <- 0.836
a <- 8.478
b <- 0.282
conc <- 0
for (i in 1:4) A[i+1,i] <- s*(1 + exp(a))/(exp(a)+exp(b*conc))
for (i in 5:6) A[i+1,i] <- qfun(conc,2)
for (i in 7:9) A[i+1,i] <- qfun(conc,3)
for (i in 10:15) A[i+1,i] <- qfun(conc,4)
#puppae
s <- 1
a <- 8.749
b <- 0.499
for (i in 16:16) A[i+1,i] <- s*(1 + exp(a))/(exp(a)+exp(b*conc)) * qfun(conc,4)
# and the reamining survival and fecundicity
A[1,17] <- 208.1
# find dominant right and left eigenvectors + lambda
ev <- eigen(A)
lev <- eigen(t(A))
# notice that k denotes the eigenvalue with max real part.
k <- which(ev$values==max(abs(Re(ev$values))))
w <- Re(ev$vector[,k])
lambda <- Re(ev$values[k])
k <- which(lev$values==max(abs(Re(lev$values))))
v <- Re(lev$vector[,k])
ndim <- dim(A)[1]
# calculate elasticity matrix
e <- matrix(NA,ncol=ndim,nrow=ndim)
for (i in 1:ndim)
{
for (j in 1:ndim)
{
e[i,j] <- v[i]*w[j] / v%*%w * A[i,j] / lambda
}
}
e
library(plot3D)
hist3D(z=e, x=1:ndim, y=1:ndim, ticktype = "detailed",xlab="future",ylab="present",
border="black",col="white",space=0.15,zlab="elasticity")
# elasticity matrix shows that all steps in the lifecycle are equally important.
##### 14 ####
A <- matrix(0,nrow=17,ncol=17)
s <- 0.836
a <- 8.478
b <- 0.282
conc <- 60 # or 30
for (i in 1:4) A[i+1,i] <- s*(1 + exp(a))/(exp(a)+exp(b*conc))
for (i in 5:6) A[i+1,i] <- qfun(conc,2)
for (i in 7:9) A[i+1,i] <- qfun(conc,3)
for (i in 10:15) A[i+1,i] <- qfun(conc,4)
#puppae
s <- 1
a <- 8.749
b <- 0.499
for (i in 16:16) A[i+1,i] <- s*(1 + exp(a))/(exp(a)+exp(b*conc)) * qfun(conc,4)
# and the reamining survival and fecundicity
A[1,17] <- 208.1
# find dominant right and left eigenvectors + lambda
ev <- eigen(A)
lev <- eigen(t(A))
k <- which(ev$values==max(abs(Re(ev$values))))
w <- Re(ev$vector[,k])
lambda <- Re(ev$values[k])
k <- which(lev$values==max(abs(Re(lev$values))))
v <- Re(lev$vector[,k])
ndim <- dim(A)[1]
ndim
ev
lev
lev
help(t)
w
v
lambda
ev$values
ev$vectors
ndim <- dim(A)[1]
# calculate elasticity matrix
e <- matrix(NA,ncol=ndim,nrow=ndim)
for (i in 1:ndim)
{
for (j in 1:ndim)
{
e[i,j] <- v[i]*w[j] / v%*%w * A[i,j] / lambda
}
}
# solutions to mandatory assignment 2
##### 1 ####
# draw a pretty picture
# E -> L; L -> P; P -> A; A -> E
##### 2 ####
# replace and reduce, alpha(C)=0.5 => C=LC50
# 0.5 = ( 1 + exp(a) ) / ( exp(a) + exp(b*LC50) ) <=>
# 0.5 * ( exp(a) + exp(b*LC50) ) = ( 1 + exp(a) ) <=>
# exp(b*LC50) = 2 + 2*exp(a) - exp(a) <=>
# LC50 = log(2+exp(a))/b
##### 3 ####
#The equation for LC50 can be found just below equation (1), parameters in Table 1.
# eggs
a <- 8.478
b <- 0.282
(log(2+exp(a)))/b
#puppae
a <- 8.749
b <- 0.499
(log(2+exp(a)))/b
##### 4 ####
# insert parameters and plot - equivalent to figure 2
x <- seq(0,100,len=1000)
#eggs
s <- 0.836
a <- 8.478
b <- 0.282
plot(x,s*(1 + exp(a))/(exp(a)+exp(b*x)),type="l")
#puppae
s <- 1
a <- 8.749
b <- 0.499
plot(x,s*(1 + exp(a))/(exp(a)+exp(b*x)),type="l")
##### 5 ####
# notice as we look for daily probability that t=1
qfun <- function(conc,Ls,tim=1)
{
switch(as.character(Ls),
"2" = {m <- 0.051; nec <- 3.73e-7; k <- 0.023; eps <- 3.474},
"3" = {m <- 0.038; nec <- 236    ; k <- 0.014; eps <- 3.171},
"4" = {m <- 0.033; nec <- 255    ; k <- 0.022; eps <- 4.234},
stop("Wrong stage specified"))
res <- exp( -m + k/eps*conc * exp(-eps*tim)*(1-exp(-eps)) - k*(conc-nec))
res[conc<nec] <- exp(-m)
return(res)
}
x <- seq(0,500,len=1000)
plot(x,qfun(x,2),xlab = "methiocarb conc in mu g / L", ylab="daily survival prob")
plot(x,qfun(x,3),xlab = "methiocarb conc in mu g / L", ylab="daily survival prob")
plot(x,qfun(x,4),xlab = "methiocarb conc in mu g / L", ylab="daily survival prob")
##### 6 ####
# riparius spends 2 days as egg, two days in L1, and L2 stages, 3 days in L4, and 7 days in L4
0.836^2 * 0.836^2 * qfun(0,2)^2 * qfun(0,3)^3 * qfun(0,4)^7 * 1
##### 7+8 ####
# make Leslie matrix
# begin with a 0 matrix of 17*17
A <- matrix(0,nrow=17,ncol=17)
# fill the sub-diagonal
# eggs and L1
s <- 0.836
a <- 8.478
b <- 0.282
conc <- 0 # concentration can be changed.
for (i in 1:4) A[i+1,i] <- s*(1 + exp(a))/(exp(a)+exp(b*conc))
for (i in 5:6) A[i+1,i] <- qfun(conc,2)
for (i in 7:9) A[i+1,i] <- qfun(conc,3)
for (i in 10:15) A[i+1,i] <- qfun(conc,4)
#puppae
s <- 1
a <- 8.749
b <- 0.499
for (i in 16:16) A[i+1,i] <- s*(1 + exp(a))/(exp(a)+exp(b*conc)) * qfun(conc,4)
# and the  fecundicity
A[1,17] <- 208.1
##### 9 ####
eigen(A) # notice the real eigenvector is last
# dominant real eigenvalue is >1, which mena that the population will increase over time.
# eigenvector shows that the population will be dominated by younger individuals
##### 10 ####
# first create population vector n
n <- numeric(17)
n[1] <- 1000
# vector to collect data
sn <- numeric(200)
sn[1] <- sum(n)
#evolve over time
for (i in 2:200)
{
n <- A %*% n
sn[i] <- sum(n)
}
plot(log10(sn),xlab="days",ylab = "log10 population")
grid()
##### 11 ####
A <- matrix(0,nrow=17,ncol=17)
# fill the sub-diagonal
# eggs and L1
s <- 0.836
a <- 8.478
b <- 0.282
conc <- 21 # methiocarb concentration
for (i in 1:4) A[i+1,i] <- s*(1 + exp(a))/(exp(a)+exp(b*conc))
for (i in 5:6) A[i+1,i] <- qfun(conc,2)
for (i in 7:9) A[i+1,i] <- qfun(conc,3)
for (i in 10:15) A[i+1,i] <- qfun(conc,4)
#puppae
s <- 1
a <- 8.749
b <- 0.499
for (i in 16:16) A[i+1,i] <- s*(1 + exp(a))/(exp(a)+exp(b*conc)) * qfun(conc,4)
# and fecundicity
A[1,17] <- 208.1
eigen(A) # notice the real eigenvector is somewhere in the middle
# dominant real eigenvalue is still >1, which mena that the population will increase over time.
# however not with the same speed as before.
# eigenvector shows that the population will be dominated by younger individuals
n <- numeric(17)
n[1] <- 1000
sn <- numeric(200)
sn[1] <- sum(n)
for (i in 2:200)
{
n <- A %*% n
sn[i] <- sum(n)
}
plot(log10(sn))
##### 12 ####
lambda <- numeric(121)
for (conc in 0:120)
{
A <- matrix(0,nrow=17,ncol=17)
# fill the sub-diagonal
# eggs and L1
s <- 0.836
a <- 8.478
b <- 0.282
for (i in 1:4) A[i+1,i] <- s*(1 + exp(a))/(exp(a)+exp(b*conc))
for (i in 5:6) A[i+1,i] <- qfun(conc,2)
for (i in 7:9) A[i+1,i] <- qfun(conc,3)
for (i in 10:15) A[i+1,i] <- qfun(conc,4)
#puppae
s <- 1
a <- 8.749
b <- 0.499
for (i in 16:16) A[i+1,i] <- s*(1 + exp(a))/(exp(a)+exp(b*conc)) * qfun(conc,4)
# and the reamining survival and fecundicity
A[1,17] <- 208.1
ev <- eigen(A)
lambda[conc+1] <- max(abs(ev$values))
}
plot(0:120,lambda,xlab = "methiocarb conc in mu g / L", ylab="lambda")
grid()
# 23 µg/l is sufficient to reduce lambda below 1.
##### 13 ####
A <- matrix(0,nrow=17,ncol=17)
s <- 0.836
a <- 8.478
b <- 0.282
conc <- 0
for (i in 1:4) A[i+1,i] <- s*(1 + exp(a))/(exp(a)+exp(b*conc))
for (i in 5:6) A[i+1,i] <- qfun(conc,2)
for (i in 7:9) A[i+1,i] <- qfun(conc,3)
for (i in 10:15) A[i+1,i] <- qfun(conc,4)
#puppae
s <- 1
a <- 8.749
b <- 0.499
for (i in 16:16) A[i+1,i] <- s*(1 + exp(a))/(exp(a)+exp(b*conc)) * qfun(conc,4)
# and the reamining survival and fecundicity
A[1,17] <- 208.1
# find dominant right and left eigenvectors + lambda
ev <- eigen(A)
lev <- eigen(t(A))
# notice that k denotes the eigenvalue with max real part.
k <- which(ev$values==max(abs(Re(ev$values))))
w <- Re(ev$vector[,k])
lambda <- Re(ev$values[k])
k <- which(lev$values==max(abs(Re(lev$values))))
v <- Re(lev$vector[,k])
ndim <- dim(A)[1]
# calculate elasticity matrix
e <- matrix(NA,ncol=ndim,nrow=ndim)
for (i in 1:ndim)
{
for (j in 1:ndim)
{
e[i,j] <- v[i]*w[j] / v%*%w * A[i,j] / lambda
}
}
e
library(plot3D)
hist3D(z=e, x=1:ndim, y=1:ndim, ticktype = "detailed",xlab="future",ylab="present",
border="black",col="white",space=0.15,zlab="elasticity")
# elasticity matrix shows that all steps in the lifecycle are equally important.
##### 14 ####
A <- matrix(0,nrow=17,ncol=17)
s <- 0.836
a <- 8.478
b <- 0.282
conc <- 60 # or 30
for (i in 1:4) A[i+1,i] <- s*(1 + exp(a))/(exp(a)+exp(b*conc))
for (i in 5:6) A[i+1,i] <- qfun(conc,2)
for (i in 7:9) A[i+1,i] <- qfun(conc,3)
for (i in 10:15) A[i+1,i] <- qfun(conc,4)
#puppae
s <- 1
a <- 8.749
b <- 0.499
for (i in 16:16) A[i+1,i] <- s*(1 + exp(a))/(exp(a)+exp(b*conc)) * qfun(conc,4)
# and the reamining survival and fecundicity
A[1,17] <- 208.1
# find dominant right and left eigenvectors + lambda
ev <- eigen(A)
lev <- eigen(t(A))
k <- which(ev$values==max(abs(Re(ev$values))))
w <- Re(ev$vector[,k])
lambda <- Re(ev$values[k])
k <- which(lev$values==max(abs(Re(lev$values))))
v <- Re(lev$vector[,k])
ndim <- dim(A)[1]
# calculate elasticity matrix
e <- matrix(NA,ncol=ndim,nrow=ndim)
for (i in 1:ndim)
{
for (j in 1:ndim)
{
e[i,j] <- v[i]*w[j] / v%*%w * A[i,j] / lambda
}
}
e
### This is the main programming script for handling the data ###
rm(list = ls())
# loading libraries
#library(dplyr)
library(gsubfn)
# loading in the sources of other functions
source("G:/Mit drev/Specialeprojekt/Programming/extracting_data_KAT.R")
source("G:/Mit drev/Specialeprojekt/Programming/data_filtering.R")
source("G:/Mit drev/Specialeprojekt/Programming/Functions.R")
# loading in the data
list[data, len_16s, len_qpcr] <- extracting_data_KAT()
?grep
infile = data
?var
# loading libraries
library(factoextra) # used to create ggplot2-based visualization
setwd("~/GitHub/Coupling-of-omics-data")
#install.packages("devtools")
devtools::install_github("stefpeschel/NetCoMi", dependencies = TRUE,
repos = c("https://cloud.r-project.org/",
BiocManager::repositories()))
write('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', file = "~/.Renviron", append = TRUE)
Sys.which("make")
install.packages("jsonlite", type = "source")
#install.packages("devtools")
devtools::install_github("stefpeschel/NetCoMi", dependencies = TRUE,
repos = c("https://cloud.r-project.org/",
BiocManager::repositories()))
#install.packages("devtools")
devtools::install_github("stefpeschel/NetCoMi", dependencies = TRUE,
repos = c("https://cloud.r-project.org/",
BiocManager::repositories()))
install.packages("GO")
=NetCoMi
?NetCoMi
??NetCoMi
install.packages("devtools")
install.packages("devtools")
devtools::install_github("stefpeschel/NetCoMi", dependencies = TRUE,
repos = c("https://cloud.r-project.org/",
BiocManager::repositories()))
#install.packages("devtools")
devtools::install_github("stefpeschel/NetCoMi", dependencies = TRUE,
repos = c("https://cloud.r-project.org/",
BiocManager::repositories()))
