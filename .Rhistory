metab_new_names <- rownames(df_metab_noblanks)
for (i in 1:length(rownam_samples_metab)) {
num_grep = as.numeric(unlist(regmatches(rownam_samples_metab[i], gregexpr("[[:digit:]]+", rownam_samples_metab[i]))))
if (length(num_grep) == 1 && num_grep > 400) {
# find which sample is talked about
metaDataRow = which(metadata_metabolomics$ï..Sample.no...MCCe. == num_grep)
# checking for TDA
if(metadata_metabolomics$System[metaDataRow]=="TDA"){tdaBin="P"}else{tdaBin="D"}
# finding biorep
biorepSample  = metadata_metabolomics$Bio.Rep[metaDataRow]
# finding time
timeSample    = metadata_metabolomics$Time[metaDataRow] / 7
# inserting into new name format
metab_new_names[i] = paste(tdaBin,biorepSample,timeSample, sep = "-")
}
}
# inserting the correct names
rownames(df_metab_noblanks) = metab_new_names
# finding the common test IDs, to make a full dataset
commonIDs <- intersect(sampleID.metatax, metab_new_names)
# only keeping the relevant testIDs
df_metab = df_metab_noblanks[metab_new_names %in% commonIDs,]
df_metax = df.full.metax[sampleID.metatax %in% commonIDs]
View(df_metax)
View(df_metab)
df_metab[,1]
# removing the additional column with information (1)
df_metab_noblanks = df_metab_noblanks[1,-c(1)]
View(df_metab_noblanks)
# removing the additional column with information (1)
df_metab_noblanks = df_metab_noblanks[,-c(1)]
#### Metabolomic data
# loading in data
df_metab_original <- read.csv("Data/metabolomic_day7,28,70.csv", header = TRUE, sep = ";")
df_metab_noblanks_tmp1 = as.data.frame(t(df_metab_original))
# naming the colnames header
colnames(df_metab_noblanks_tmp1) = df_metab_noblanks_tmp1[1,]
# removing the first row
df_metab_noblanks = df_metab_noblanks_tmp1[-c(1),]
# loading in metadata metabolomics sheet - changed data to .csv first, to make it work
metadata_metabolomics  <- read.csv("Data/Metadata-metabolomics.csv", fill = TRUE, header = TRUE, sep = ";")
# fetching two first rows / names
rownam_samples_metab  <- rownames(df_metab_noblanks)
addit_info_samples    <- df_metab_noblanks[,1]
# running through the names, matching them with phyloseq naming
metab_new_names <- rownames(df_metab_noblanks)
for (i in 1:length(rownam_samples_metab)) {
num_grep = as.numeric(unlist(regmatches(rownam_samples_metab[i], gregexpr("[[:digit:]]+", rownam_samples_metab[i]))))
if (length(num_grep) == 1 && num_grep > 400) {
# find which sample is talked about
metaDataRow = which(metadata_metabolomics$ï..Sample.no...MCCe. == num_grep)
# checking for TDA
if(metadata_metabolomics$System[metaDataRow]=="TDA"){tdaBin="P"}else{tdaBin="D"}
# finding biorep
biorepSample  = metadata_metabolomics$Bio.Rep[metaDataRow]
# finding time
timeSample    = metadata_metabolomics$Time[metaDataRow] / 7
# inserting into new name format
metab_new_names[i] = paste(tdaBin,biorepSample,timeSample, sep = "-")
}
}
# inserting the correct names
rownames(df_metab_noblanks) = metab_new_names
# removing the additional column with information (1)
df_metab_noblanks_tmp3 = df_metab_noblanks[,-c(1)]
View(df_metab_noblanks_tmp3)
# finding the common test IDs, to make a full dataset
commonIDs <- intersect(sampleID.metatax, metab_new_names)
# only keeping the relevant testIDs
df_metab = df_metab_noblanks_tmp3[metab_new_names %in% commonIDs,]
df_metax = df.full.metax[sampleID.metatax %in% commonIDs]
View(df_metab)
data_metab = cbind(metab_new_names,df_metab_noblanks_tmp3)
data_metax = cbind(sampleID.metatax,df.full.metax)
# only keeping the relevant testIDs
df_metab = df_metab_noblanks_tmp3[metab_new_names %in% commonIDs,]
df_metax = df.full.metax[sampleID.metatax %in% commonIDs]
View(data_metax)
View(data_metab)
data_metab[1,1]
data_metab[3,1]
data_metab[5,1]
data_metab[5,1] %in% data_metab
data_metab[5,1] %in% data_metax
which(data_metax$sampleID.metatax == "D-2-1")
data_metax[54]
data_metax$sampleID.metatax[54]
?in
?%in%
metab_new_names
commonIDs
data_metab
View(df_metax)
data_metab = cbind(metab_new_names,df_metab_noblanks_tmp3)
data_metax = cbind(sampleID.metatax,df.full.metax)
# only keeping the relevant testIDs
df_metab = df_metab_noblanks_tmp3[metab_new_names %in% commonIDs,]
df_metax = df.full.metax[sampleID.metatax %in% commonIDs]
# only keeping the relevant testIDs
df_metab = data_metab[metab_new_names %in% commonIDs,]
df_metax = data_metax[sampleID.metatax %in% commonIDs]
sampleID.metatax
df.full.metax
metab_new_names
sampleID.metatax
commonIDs
df_metax = data_metax[sampleID.metatax %in% commonIDs,]
rm(list(ls()))
rm(list(ls())
rm(list=ls())
# loading libraries
library(phyloseq)
library(stringr)
library(gsubfn)
# loading data
data_phys_original  <- readRDS("Data/allDataMetataxonomicNCLTEE.rds")
# The actual data
df.otu.metatax      <- as.data.frame(data_phys_original@otu_table)
# The results / variables
df.tax.metatax      <- as.data.frame(data_phys_original@tax_table)
# The sample IDs
sampleID.metatax    <- data_phys_original@sam_data$sample.name
## setting up dataframe similar to Katrines
df.fulldata.metax <- as.data.frame(t(df.otu.metatax))
rownames(df.fulldata.metax) = sampleID.metatax
# making string array with colnames
colnames_array_metatax <- str_c("DATA.",str_replace_na(df.tax.metatax$domain, replacement="NA"),"_",
str_replace_na(df.tax.metatax$phylum,  replacement="NA"),"_",
str_replace_na(df.tax.metatax$class,   replacement="NA"),"_",
str_replace_na(df.tax.metatax$order,   replacement="NA"),"_",
str_replace_na(df.tax.metatax$family,  replacement="NA"),"_",
str_replace_na(df.tax.metatax$genus,   replacement="NA"),"_",
str_replace_na(df.tax.metatax$species, replacement="NA"))
colnames(df.fulldata.metax) = colnames_array_metatax
# saving information on phaeobacter presence
array.phaebac.bin <- data_phys_original@sam_data$phaeobacter
# moving up to genus level or staying at species
whichTaxLevel <- "species"
if (whichTaxLevel=="genus") {
# moving up in taxonomy for the 16s data, going from species to genus
origNames <- colnames(df.fulldata.metax)
newNames <- apply(str_split_fixed(string = origNames, pattern = "[_]",7)[,1:6],1, paste, collapse="_")
length(unique(newNames))
uniqNames=unique(newNames)
newDat=data.frame(dummy=1:NROW(df.fulldata.metax))
#j=uniqNames[1]
for(j in uniqNames) {
jIndx=grep(j,origNames )
if(length(jIndx)>1) {
newDat=cbind(newDat,rowSums(df.fulldata.metax[,jIndx]))
} else {
newDat=cbind(newDat,(df.fulldata.metax[,jIndx]))
}
}
newDat=newDat[,-1]
colnames(newDat)=uniqNames
# now making that new data into 16s data set
df.fulldata.metax = newDat
}
df.full.metax <- cbind(array.phaebac.bin,df.fulldata.metax)
#### Metabolomic data
# loading in data
df_metab_original <- read.csv("Data/metabolomic_day7,28,70.csv", header = TRUE, sep = ";")
df_metab_noblanks_tmp1 = as.data.frame(t(df_metab_original))
# naming the colnames header
colnames(df_metab_noblanks_tmp1) = df_metab_noblanks_tmp1[1,]
# removing the first row
df_metab_noblanks = df_metab_noblanks_tmp1[-c(1),]
# pure_data_qpcr  = subset(pure_data_qpcr, select = -c(PIG_DATE, OUA))
# loading in metadata metabolomics sheet - changed data to .csv first, to make it work
metadata_metabolomics  <- read.csv("Data/Metadata-metabolomics.csv", fill = TRUE, header = TRUE, sep = ";")
# fetching two first rows / names
rownam_samples_metab  <- rownames(df_metab_noblanks)
addit_info_samples    <- df_metab_noblanks[,1]
# running through the names, matching them with phyloseq naming
metab_new_names <- rownames(df_metab_noblanks)
for (i in 1:length(rownam_samples_metab)) {
num_grep = as.numeric(unlist(regmatches(rownam_samples_metab[i], gregexpr("[[:digit:]]+", rownam_samples_metab[i]))))
if (length(num_grep) == 1 && num_grep > 400) {
# find which sample is talked about
metaDataRow = which(metadata_metabolomics$ï..Sample.no...MCCe. == num_grep)
# checking for TDA
if(metadata_metabolomics$System[metaDataRow]=="TDA"){tdaBin="P"}else{tdaBin="D"}
# finding biorep
biorepSample  = metadata_metabolomics$Bio.Rep[metaDataRow]
# finding time
timeSample    = metadata_metabolomics$Time[metaDataRow] / 7
# inserting into new name format
metab_new_names[i] = paste(tdaBin,biorepSample,timeSample, sep = "-")
}
}
# inserting the correct names
rownames(df_metab_noblanks) = metab_new_names
# removing the additional column with information (1)
df_metab_noblanks_tmp3 = df_metab_noblanks[,-c(1)]
# finding the common test IDs, to make a full dataset
commonIDs <- intersect(sampleID.metatax, metab_new_names)
data_metab = df_metab_noblanks_tmp3
data_metax = df.full.metax
# only keeping the relevant testIDs
df_metab = data_metab[metab_new_names %in% commonIDs,]
df_metax = data_metax[sampleID.metatax %in% commonIDs,]
# only keeping the relevant testIDs
df_metab = sort(data_metab[metab_new_names %in% commonIDs,])
?sort
# only keeping the relevant testIDs
df_metab = order(data_metab[metab_new_names %in% commonIDs,][,1], decreasing = FALSE)
df_metax = order(data_metax[sampleID.metatax %in% commonIDs,][,1], decreasing = FALSE)
df_metab = order(rownames(df_metab), decreasing = FALSE)
df_metab = df_metab[order(df_metab[,1], decreasing = FALSE,)
df_metab = df_metab[order(df_metab[,1], decreasing = FALSE,])
df_metab = df_metab[order(commonIDs),]
df_metab
# only keeping the relevant testIDs
df_metab = data_metab[metab_new_names %in% commonIDs,]
df_metax = data_metax[sampleID.metatax %in% commonIDs,]
df_metab = df_metab[order(commonIDs),]
df_metax = df_metax[order(commonIDs),]
df_metab = df_metab[order(commonIDs, decreasing = FALSE),]
df_metax = df_metax[order(commonIDs, decreasing = FALSE),]
sort(rownames(df_metab))
sort(rownames(df_metax))
df_metab = df_metab[sort(commonIDs, decreasing = FALSE),]
df_metax = df_metax[sort(commonIDs, decreasing = FALSE),]
complete_data <- cbind(df_metax, df_metab, deparse.level = 1)
View(complete_data)
inData = complete_data
View(complete_data)
data = complete_data
phaobacBin <- inData$array.phaebac.bin
phaobacBin <- data$array.phaebac.bin
inData = subset(data, select = -c(array.phaebac.bin))
# if the variance is equal to zero, then its a zero-column
#which(unname(apply(inData, 2, var))==0)
throwAway <- which(apply(inData, 2, var)==0)[]
# dropping columns by index
inData = inData[, -throwAway]
rm(throwAway) # to save memory
print("Generating metadata...")
## finding different interesting information on the set
## mean, var, STD, ratio of zeros,
meanData  <- unname(apply(inData, 2, mean))
stdData   <- unname(apply(inData, 2, sd))
varData   <- unname(apply(inData, 2, var))
ratioData <- unname(apply(inData, 2, function(x){length(which(x==0))/length(x)}))
CVData    <- unname(apply(inData, 2, function(x){sd(x)/mean(x)}))
plot(sort(meanData), main = "Mean Data")
plot(sort(stdData), main = "Standard Variations")
plot(sort(varData), main = "Variance")
plot(sort(ratioData), main = "Singleton ratios")
plot(sort(CVData), main = "Relative standard deviation")
plot(sort(meanData), main = "Mean Data")
# fitting Michaelis-Menten function to data
print("Fitting Michaelis-Menten function...")
time_frame <- seq(from = 1, to = length(ratioData), by = 1)
mmModel <- nls(sort(ratioData) ~ Vm*time_frame/(K+time_frame),
start = list(Vm=max(ratioData), K=max(time_frame) / 2))
# parameters estimated including confidence interval
coef(mmModel)
confint(mmModel, level = 0.9)
# defining to estimated parameters
Vmax = coef(mmModel)[[1]]
K    = coef(mmModel)[[2]]
# visualizing the model in relation to ratio Data
plot(sort(ratioData) ~ time_frame, col = "grey")
lines(predict(mmModel) ~ time_frame, lwd = 3, col = "dark red")
# finding local maxima, potentiel knee points
kneePoints_collected <- which(diff(sign(diff(ratioData)))==-2)+1
# finding the linear fit from origo to asymptote
a_linearFit <- max(ratioData) / max(time_frame)
b_linearFit <- min(ratioData) - a_linearFit*min(time_frame)
max_x = which(sort(ratioData)>=max(ratioData)*0.97)[1]
max_y = Vmax*max_x / (K+max_x)
a_linearFit <- (max_y - min(ratioData)) / (max_x-min(time_frame))
b_linearFit <- min(ratioData) - a_linearFit*min(time_frame)
abline(a = b_linearFit, b=a_linearFit)
# using distance formular on all knee points to line
# distance formula: d = abs(a*x+b-y)/sqrt(a^2+1)
longest_distance  <- 0
longest_x         <- 0
#i=kneePoints_collected[400]
for (i in which(kneePoints_collected<=max_x)) {
temp_x = i
temp_y = Vmax*temp_x / (K+temp_x)
#points(temp_x, temp_y)
dist = abs(a_linearFit*temp_x + b_linearFit-temp_y)/sqrt(a_linearFit^2+1)
if (dist >= longest_distance) {longest_distance = dist; longest_x = temp_x}
}
# defining the cutoff threshold
threshold_ratio <- Vmax*longest_x / (K+longest_x)
points(longest_x, threshold_ratio)
abline(h = threshold_ratio)
# if the ratioData is above the found cutoff, it is to be removed
keepIn <- which(ratioData <= threshold_ratio)
# dropping columns by index
sprintf("Filtering out data with zero-ratio above %f...", threshold_ratio)
inData = inData[, keepIn]
rm(keepIn) # to save memory
meanData  <- unname(apply(inData, 2, mean))
stdData   <- unname(apply(inData, 2, sd))
varData   <- unname(apply(inData, 2, var))
ratioData <- unname(apply(inData, 2, function(x){length(which(x==0))/length(x)}))
CVData    <- unname(apply(inData, 2, function(x){sd(x)/mean(x)}))
plot(sort(meanData), main = "Mean Data")
plot(sort(stdData), main = "Standard Variations")
plot(sort(varData), main = "Variance")
plot(sort(ratioData), main = "Singleton ratios")
plot(sort(CVData), main = "Relative standard deviation")
inData = cbind(testID, OUA, inData)
outData = inData
rm(list=setdiff(ls(), "outData"))
print("Filtering done...")
### Script to extract data from Nathalie and Scott ###
### Metataxonomic and metabolomic data ###
# loading libraries
library(phyloseq)
library(stringr)
library(gsubfn)
# loading data
data_phys_original  <- readRDS("Data/allDataMetataxonomicNCLTEE.rds")
# The actual data
df.otu.metatax      <- as.data.frame(data_phys_original@otu_table)
# The results / variables
df.tax.metatax      <- as.data.frame(data_phys_original@tax_table)
# The sample IDs
sampleID.metatax    <- data_phys_original@sam_data$sample.name
## setting up dataframe similar to Katrines
df.fulldata.metax <- as.data.frame(t(df.otu.metatax))
rownames(df.fulldata.metax) = sampleID.metatax
# making string array with colnames
colnames_array_metatax <- str_c("DATA.",str_replace_na(df.tax.metatax$domain, replacement="NA"),"_",
str_replace_na(df.tax.metatax$phylum,  replacement="NA"),"_",
str_replace_na(df.tax.metatax$class,   replacement="NA"),"_",
str_replace_na(df.tax.metatax$order,   replacement="NA"),"_",
str_replace_na(df.tax.metatax$family,  replacement="NA"),"_",
str_replace_na(df.tax.metatax$genus,   replacement="NA"),"_",
str_replace_na(df.tax.metatax$species, replacement="NA"))
colnames(df.fulldata.metax) = colnames_array_metatax
# saving information on phaeobacter presence
array.phaebac.bin <- data_phys_original@sam_data$phaeobacter
# moving up to genus level or staying at species
whichTaxLevel <- "species"
if (whichTaxLevel=="genus") {
# moving up in taxonomy for the 16s data, going from species to genus
origNames <- colnames(df.fulldata.metax)
newNames <- apply(str_split_fixed(string = origNames, pattern = "[_]",7)[,1:6],1, paste, collapse="_")
length(unique(newNames))
uniqNames=unique(newNames)
newDat=data.frame(dummy=1:NROW(df.fulldata.metax))
#j=uniqNames[1]
for(j in uniqNames) {
jIndx=grep(j,origNames )
if(length(jIndx)>1) {
newDat=cbind(newDat,rowSums(df.fulldata.metax[,jIndx]))
} else {
newDat=cbind(newDat,(df.fulldata.metax[,jIndx]))
}
}
newDat=newDat[,-1]
colnames(newDat)=uniqNames
# now making that new data into 16s data set
df.fulldata.metax = newDat
}
df.full.metax <- cbind(array.phaebac.bin,df.fulldata.metax)
#### Metabolomic data
# loading in data
df_metab_original <- read.csv("Data/metabolomic_day7,28,70.csv", header = TRUE, sep = ";")
df_metab_noblanks_tmp1 = as.data.frame(t(df_metab_original))
# naming the colnames header
colnames(df_metab_noblanks_tmp1) = df_metab_noblanks_tmp1[1,]
# removing the first row
df_metab_noblanks = df_metab_noblanks_tmp1[-c(1),]
# pure_data_qpcr  = subset(pure_data_qpcr, select = -c(PIG_DATE, OUA))
# loading in metadata metabolomics sheet - changed data to .csv first, to make it work
metadata_metabolomics  <- read.csv("Data/Metadata-metabolomics.csv", fill = TRUE, header = TRUE, sep = ";")
# fetching two first rows / names
rownam_samples_metab  <- rownames(df_metab_noblanks)
addit_info_samples    <- df_metab_noblanks[,1]
# running through the names, matching them with phyloseq naming
metab_new_names <- rownames(df_metab_noblanks)
for (i in 1:length(rownam_samples_metab)) {
num_grep = as.numeric(unlist(regmatches(rownam_samples_metab[i], gregexpr("[[:digit:]]+", rownam_samples_metab[i]))))
if (length(num_grep) == 1 && num_grep > 400) {
# find which sample is talked about
metaDataRow = which(metadata_metabolomics$ï..Sample.no...MCCe. == num_grep)
# checking for TDA
if(metadata_metabolomics$System[metaDataRow]=="TDA"){tdaBin="P"}else{tdaBin="D"}
# finding biorep
biorepSample  = metadata_metabolomics$Bio.Rep[metaDataRow]
# finding time
timeSample    = metadata_metabolomics$Time[metaDataRow] / 7
# inserting into new name format
metab_new_names[i] = paste(tdaBin,biorepSample,timeSample, sep = "-")
}
}
# inserting the correct names
rownames(df_metab_noblanks) = metab_new_names
# removing the additional column with information (1)
df_metab_noblanks_tmp3 = df_metab_noblanks[,-c(1)]
# finding the common test IDs, to make a full dataset
commonIDs <- intersect(sampleID.metatax, metab_new_names)
#data_metab = cbind(metab_new_names,df_metab_noblanks_tmp3)
#data_metax = cbind(sampleID.metatax,df.full.metax)
data_metab = df_metab_noblanks_tmp3
data_metax = df.full.metax
# only keeping the relevant testIDs
df_metab = data_metab[metab_new_names %in% commonIDs,]
df_metax = data_metax[sampleID.metatax %in% commonIDs,]
df_metab = df_metab[sort(commonIDs, decreasing = FALSE),]
df_metax = df_metax[sort(commonIDs, decreasing = FALSE),]
complete_data <- cbind(df_metax, df_metab, deparse.level = 1)
complete_data <- cbind(testID, OUA, pure_data_16s, pure_data_qpcr, deparse.level = 1)
rm(list=ls())
### Script to extract data from Nathalie and Scott ###
### Metataxonomic and metabolomic data ###
# loading libraries
library(phyloseq)
library(stringr)
library(gsubfn)
# loading data
data_phys_original  <- readRDS("Data/allDataMetataxonomicNCLTEE.rds")
# The actual data
df.otu.metatax      <- as.data.frame(data_phys_original@otu_table)
# The results / variables
df.tax.metatax      <- as.data.frame(data_phys_original@tax_table)
# The sample IDs
sampleID.metatax    <- data_phys_original@sam_data$sample.name
## setting up dataframe similar to Katrines
df.fulldata.metax <- as.data.frame(t(df.otu.metatax))
rownames(df.fulldata.metax) = sampleID.metatax
# making string array with colnames
colnames_array_metatax <- str_c("DATA.",str_replace_na(df.tax.metatax$domain, replacement="NA"),"_",
str_replace_na(df.tax.metatax$phylum,  replacement="NA"),"_",
str_replace_na(df.tax.metatax$class,   replacement="NA"),"_",
str_replace_na(df.tax.metatax$order,   replacement="NA"),"_",
str_replace_na(df.tax.metatax$family,  replacement="NA"),"_",
str_replace_na(df.tax.metatax$genus,   replacement="NA"),"_",
str_replace_na(df.tax.metatax$species, replacement="NA"))
colnames(df.fulldata.metax) = colnames_array_metatax
# saving information on phaeobacter presence
array.phaebac.bin <- data_phys_original@sam_data$phaeobacter
# moving up to genus level or staying at species
whichTaxLevel <- "species"
if (whichTaxLevel=="genus") {
# moving up in taxonomy for the 16s data, going from species to genus
origNames <- colnames(df.fulldata.metax)
newNames <- apply(str_split_fixed(string = origNames, pattern = "[_]",7)[,1:6],1, paste, collapse="_")
length(unique(newNames))
uniqNames=unique(newNames)
newDat=data.frame(dummy=1:NROW(df.fulldata.metax))
#j=uniqNames[1]
for(j in uniqNames) {
jIndx=grep(j,origNames )
if(length(jIndx)>1) {
newDat=cbind(newDat,rowSums(df.fulldata.metax[,jIndx]))
} else {
newDat=cbind(newDat,(df.fulldata.metax[,jIndx]))
}
}
newDat=newDat[,-1]
colnames(newDat)=uniqNames
# now making that new data into 16s data set
df.fulldata.metax = newDat
}
df.full.metax <- cbind(array.phaebac.bin,df.fulldata.metax)
#### Metabolomic data
# loading in data
df_metab_original <- read.csv("Data/metabolomic_day7,28,70.csv", header = TRUE, sep = ";")
df_metab_noblanks_tmp1 = as.data.frame(t(df_metab_original))
# naming the colnames header
colnames(df_metab_noblanks_tmp1) = df_metab_noblanks_tmp1[1,]
# removing the first row
df_metab_noblanks = df_metab_noblanks_tmp1[-c(1),]
# pure_data_qpcr  = subset(pure_data_qpcr, select = -c(PIG_DATE, OUA))
# loading in metadata metabolomics sheet - changed data to .csv first, to make it work
metadata_metabolomics  <- read.csv("Data/Metadata-metabolomics.csv", fill = TRUE, header = TRUE, sep = ";")
# fetching two first rows / names
rownam_samples_metab  <- rownames(df_metab_noblanks)
addit_info_samples    <- df_metab_noblanks[,1]
# running through the names, matching them with phyloseq naming
metab_new_names <- rownames(df_metab_noblanks)
for (i in 1:length(rownam_samples_metab)) {
num_grep = as.numeric(unlist(regmatches(rownam_samples_metab[i], gregexpr("[[:digit:]]+", rownam_samples_metab[i]))))
if (length(num_grep) == 1 && num_grep > 400) {
# find which sample is talked about
metaDataRow = which(metadata_metabolomics$ï..Sample.no...MCCe. == num_grep)
# checking for TDA
if(metadata_metabolomics$System[metaDataRow]=="TDA"){tdaBin="P"}else{tdaBin="D"}
# finding biorep
biorepSample  = metadata_metabolomics$Bio.Rep[metaDataRow]
# finding time
timeSample    = metadata_metabolomics$Time[metaDataRow] / 7
# inserting into new name format
metab_new_names[i] = paste(tdaBin,biorepSample,timeSample, sep = "-")
}
}
# inserting the correct names
rownames(df_metab_noblanks) = metab_new_names
# removing the additional column with information (1)
df_metab_noblanks_tmp3 = df_metab_noblanks[,-c(1)]
# finding the common test IDs, to make a full dataset
commonIDs <- intersect(sampleID.metatax, metab_new_names)
#data_metab = cbind(metab_new_names,df_metab_noblanks_tmp3)
#data_metax = cbind(sampleID.metatax,df.full.metax)
data_metab = df_metab_noblanks_tmp3
data_metax = df.full.metax
# only keeping the relevant testIDs
df_metab = data_metab[metab_new_names %in% commonIDs,]
df_metax = data_metax[sampleID.metatax %in% commonIDs,]
df_metab = df_metab[sort(commonIDs, decreasing = FALSE),]
df_metax = df_metax[sort(commonIDs, decreasing = FALSE),]
complete_data <- cbind(df_metax, df_metab, deparse.level = 1)
